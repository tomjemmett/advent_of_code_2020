[["day-1.html", "Advent of Code 2020 Day 1 Day 1 1.1 Part 1 1.2 Part 2", " Advent of Code 2020 Tom Jemmett 2020-12-02 Day 1 Day 1 This is my attempt to solve Day 1. sample &lt;- c(1721, 979, 366, 299, 675, 1456) actual &lt;- read_lines(&quot;day_01_input.txt&quot;) %&gt;% as.integer() 1.1 Part 1 The naive approach to solving todays problem is to simple loop through the list twice, checking to see if the condition is met. If it is, immediately return that value. If we reach the end of both loops without finding the solution we can return NULL to indicate no result found. part_1_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input)-1)) { for (j in (i+1):length(input)) { if (input[[i]] + input[[j]] == target) return (input[[i]] * input[[j]]) } } NULL } We can test that this method works: part_1_naive(sample, 2020) == 514579 ## [1] TRUE This approach could be improved, we can sort the list, then create two pointers: the start and end of the list. If we add these two numbers up and exceed the target then we can decrease the higher number pointer. If the number is lower that the target we increase the lower number pointer. part_1_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) i &lt;- 1 j &lt;- length(input) input &lt;- sort(input) while (i &lt;= j) { v &lt;- input[[i]] + input[[j]] if (v == target) { return (input[[i]] * input[[j]]) } else if (v &lt; target) { i &lt;- i + 1 } else { j &lt;- j - 1 } } NULL } Again, we can test that this method works. part_1_improved(sample, 2020) == 514579 ## [1] TRUE We can now use our improved algorithm to get the result for part 1: part_1_improved(actual, 2020) ## [1] 793524 1.1.1 is the improved algorithm any better? bench::mark(part_1_naive(sample, 2020), part_1_improved(sample, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(sample, 2020) 1.5us 1.7us 534728. 0B 0 ## 2 part_1_improved(sample, 2020) 29.8us 34.3us 28619. 0B 11.5 For me, the improved algorithm actually takes longer on the sample data! This is because the improved algorithm has to sort the data, which is costly, and then it performs far more comparisons per iteration. However, when we have more data, these extra steps lead to big improvements, as can be seen when running with the actual data. bench::mark(part_1_naive(actual, 2020), part_1_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(actual, 2020) 467.5us 493.3us 1926. 0B 0 ## 2 part_1_improved(actual, 2020) 47.1us 50.5us 18952. 1.66KB 8.20 The improved algorithm was roughly 10x faster for me on the actual data. 1.2 Part 2 We can alter the naive approach from part 1 by adding in an extra for loop. part_2_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input) - 2)) { for (j in (i + 1):(length(input) - 1)) { for (k in (j + 1):length(input)) { if (input[[i]] + input[[j]] + input[[k]] == target) return (prod(input[c(i, j, k)])) } } } NULL } Again, we can test that this method works on the sample. part_2_naive(sample, 2020) == 241861950 ## [1] TRUE Its much harder to adapt the improved algorithm though. My best approach involves a binary search. This function takes a sorted array, a target value, a current index into the array, and the current min/max extents to search. If the value at position i in array is less than target, we look in the left half of the array, chopping it in half by reducing max. Likewise, if the value is greater than target, we look in the right half of the array, chopping it in half by increasing min. binary_search &lt;- function(arr, target, i, min, max) { if (arr[[i]] == target) { return(i) } else if (target &lt; arr[[i]]) { max &lt;- i ni &lt;- (min + i) %/% 2 } else { min &lt;- i ni &lt;- (max + i) %/% 2 } if (ni == i) { NULL } else { binary_search(arr, target, ni, min, max) } } Our improved algorithm for part 2 involves creating two for loops to search from the end of the (sorted) input. We then remove the third loop by using a binary search to find the target value quicker. In the two for loops we first calculate the value of the adding these two items together, quickly checking to see if there is a possible solution (and exiting early if not). Then, we perform a binary search on the rest of the array for the amount required to make v equal target (2020). If we find the value, then we simply return the results. Else we continue the search by looping. part_2_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) input &lt;- sort(input) for (j in length(input):3) { for (i in (j - 1):2) { v &lt;- sum(input[c(i, j)]) # early termination if (v &gt;= target) next() if (v + input[[i - 1]] &lt; target) next() # binary search for a suitable value k &lt;- binary_search(input, target - v, (i + 1) %/% 2, 1, (i - 1)) if (!is.null(k)) { return (prod(input[c(i, j, k)])) } } } NULL } We can once again test that our method works on the sample data: part_2_improved(sample, 2020) == 241861950 ## [1] TRUE We can now run both approaches to see what the result is: part_2_naive(actual, 2020) ## [1] 61515678 part_2_improved(actual, 2020) ## [1] 61515678 1.2.1 Is our improved algorithm better this time? Once again, we can benchmark the two approaches. bench::mark(part_2_naive(actual, 2020), part_2_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_2_naive(actual, 2020) 86.51ms 87.15ms 11.4 0B 0 ## 2 part_2_improved(actual, 2020) 9.14ms 9.53ms 104. 1.66KB 42.7 On my machine the improved approach is again about 10x quicker, though there are more memory allocations and GC (garbage collections) happening, so the total execution time is not quite 10x. "]]
