[["index.html", "Advent of Code 2020 Introduction", " Advent of Code 2020 Tom Jemmett 2020-12-11 Introduction This is my attempt to complete the Advent of Code 2020 in R using RMarkdown, along with bookdown to render the site. The book will automatically be rebuilt using GitHub actions and hosted using GitHub Pages. "],["report-repair.html", "Day 1 Report Repair 1.1 Part 1 1.2 Part 2 1.3 Extra: Implementing in Python", " Day 1 Report Repair This is my attempt to solve Day 1. sample &lt;- read_lines(&quot;samples/day_01_sample.txt&quot;) %&gt;% as.integer() actual &lt;- read_lines(&quot;inputs/day_01_input.txt&quot;) %&gt;% as.integer() 1.1 Part 1 The naive approach to solving today’s problem is to simple loop through the list twice, checking to see if the condition is met. If it is, immediately return that value. If we reach the end of both loops without finding the solution we can return NULL to indicate no result found. part_1_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input)-1)) { for (j in (i+1):length(input)) { if (input[[i]] + input[[j]] == target) return (input[[i]] * input[[j]]) } } NULL } We can test that this method works: part_1_naive(sample, 2020) == 514579 ## [1] TRUE This approach could be improved, we can sort the list, then create two pointers: the start and end of the list. If we add these two numbers up and exceed the target then we can decrease the higher number pointer. If the number is lower that the target we increase the lower number pointer. part_1_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) i &lt;- 1 j &lt;- length(input) input &lt;- sort(input) while (i &lt;= j) { v &lt;- input[[i]] + input[[j]] if (v == target) { return (input[[i]] * input[[j]]) } else if (v &lt; target) { i &lt;- i + 1 } else { j &lt;- j - 1 } } NULL } Again, we can test that this method works. part_1_improved(sample, 2020) == 514579 ## [1] TRUE We can now use our improved algorithm to get the result for part 1: part_1_improved(actual, 2020) ## [1] 793524 1.1.1 is the improved algorithm any better? bench::mark(part_1_naive(sample, 2020), part_1_improved(sample, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(sample, 2020) 2.81µs 3.46µs 268796. 0B 26.9 ## 2 part_1_improved(sample, 2020) 61.17µs 66.99µs 14378. 0B 17.0 For me, the improved algorithm actually takes longer on the sample data! This is because the improved algorithm has to sort the data, which is costly, and then it performs far more comparisons per iteration. However, when we have more data, these extra steps lead to big improvements, as can be seen when running with the actual data. bench::mark(part_1_naive(actual, 2020), part_1_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(actual, 2020) 684µs 711µs 1376. 0B 0 ## 2 part_1_improved(actual, 2020) 86.6µs 90.6µs 10749. 1.66KB 14.9 The improved algorithm was roughly 10x faster for me on the actual data. 1.2 Part 2 We can alter the naive approach from part 1 by adding in an extra for loop. part_2_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input) - 2)) { for (j in (i + 1):(length(input) - 1)) { for (k in (j + 1):length(input)) { if (input[[i]] + input[[j]] + input[[k]] == target) return (prod(input[c(i, j, k)])) } } } NULL } Again, we can test that this method works on the sample. part_2_naive(sample, 2020) == 241861950 ## [1] TRUE It’s much harder to adapt the improved algorithm though. My best approach involves a binary search. This function takes a sorted array, a target value, a current index into the array, and the current min/max extents to search. If the value at position i in array is less than target, we look in the left half of the array, chopping it in half by reducing max. Likewise, if the value is greater than target, we look in the right half of the array, chopping it in half by increasing min. binary_search &lt;- function(arr, target, i, min, max) { if (arr[[i]] == target) { return(i) } else if (target &lt; arr[[i]]) { max &lt;- i ni &lt;- (min + i) %/% 2 } else { min &lt;- i ni &lt;- (max + i) %/% 2 } if (ni == i) { NULL } else { binary_search(arr, target, ni, min, max) } } Our improved algorithm for part 2 involves creating two for loops to search from the end of the (sorted) input. We then remove the third loop by using a binary search to find the target value quicker. In the two for loops we first calculate the value of the adding these two items together, quickly checking to see if there is a possible solution (and exiting early if not). Then, we perform a binary search on the rest of the array for the amount required to make v equal target (2020). If we find the value, then we simply return the results. Else we continue the search by looping. part_2_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) input &lt;- sort(input) for (j in length(input):3) { for (i in (j - 1):2) { v &lt;- sum(input[c(i, j)]) # early termination if (v &gt;= target) next() if (v + input[[i - 1]] &lt; target) next() # binary search for a suitable value k &lt;- binary_search(input, target - v, (i + 1) %/% 2, 1, (i - 1)) if (!is.null(k)) { return (prod(input[c(i, j, k)])) } } } NULL } We can once again test that our method works on the sample data: part_2_improved(sample, 2020) == 241861950 ## [1] TRUE We can now run both approaches to see what the result is: part_2_naive(actual, 2020) ## [1] 61515678 part_2_improved(actual, 2020) ## [1] 61515678 1.2.1 Is our improved algorithm better this time? Once again, we can benchmark the two approaches. bench::mark(part_2_naive(actual, 2020), part_2_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_2_naive(actual, 2020) 110.7ms 112.6ms 8.82 0B 2.20 ## 2 part_2_improved(actual, 2020) 15.4ms 16.1ms 62.3 1.66KB 478. On my machine the improved approach is again about 10x quicker. 1.3 Extra: Implementing in Python I wanted to have a go at implementing my improved algorithm in python, but we can take advantage of sets to get even better performance and do away with the need to sort the list and perform binary search (asking if a value is in a set is a constant time operation in python - it’s near instantaneous). library(reticulate) def part_2_py(input_values, target): # convert the s = { i for i in input_values } # outer loop: we need to have at least 3 items to check while len(s) &gt; 2: # remove a value from the set j = s.pop() # take a copy of the set: if we don&#39;t find a solution for j then we need to # continue with the set as it was at this point t = s.copy() while len(t) &gt; 1: # remove a value from the copied set i = t.pop() # the value to reach the target k = target - i - j # is k in the set? I.e. does i + j + k == target? if k in t: return i * j * k # no solution, return none return none bench::mark(part_2_improved(actual, 2020), py$part_2_py(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_2_improved(actual, 2020) 15.07ms 15.43ms 63.7 1.66KB 38.9 ## 2 py$part_2_py(actual, 2020) 1.29ms 1.34ms 744. 17.45KB 3.04 "],["password-philosophy.html", "Day 2 Password Philosophy 2.1 Part 1 2.2 Part 2", " Day 2 Password Philosophy This is my attempt to solve Day 2. sample &lt;- read_lines(&quot;samples/day_02_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_02_input.txt&quot;) 2.1 Part 1 We need to convert each string into a list that contains the following: minimum number of occurrences of the character maximum number of occurrences of the character the character that must be present the password Originally, I wrote the following function to handle this step: split_input &lt;- function(input) { input %&gt;% # first, split the string into the bit before the password, and the password str_split(&quot;: &quot;) %&gt;% # now, we can iterate over the results (each line of data) map(function(.x) { # find the min/max values from the first part of the input string .x mv &lt;- .x[[1]] %&gt;% # we can remove the last 2 characters of the string (the character) str_sub(1, -3) %&gt;% # now we can split the string into the min and max values str_split(&quot;-&quot;) %&gt;% # str_split is vectorised, but we only want the first results as we are # dealing with one line at a time: # the first result will contain two values pluck(1) %&gt;% # now convert these to integers as.integer() # we can now return the results list( min = mv[[1]], max = mv[[2]], character = str_sub(.x[[1]], -1, -1), password = .x[[2]] ) }) } But, after seeing a post by @antoine_fabri on Twitter I discovered the {unglue} package which makes this much easier, and neater! split_input &lt;- function(input) { unglue::unglue(input, &quot;{min}-{max} {character}: {password}&quot;, convert = TRUE) } We can see what our split_input function does to the sample data, looking at just the first item str(split_input(sample)[[1]]) ## &#39;data.frame&#39;: 1 obs. of 4 variables: ## $ min : int 1 ## $ max : int 3 ## $ character: chr &quot;a&quot; ## $ password : chr &quot;abcde&quot; Now we can build a function to return the valid passwords. part_1_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # extract the matching values from the string, we can then count the size of # the vector to find how many times that character appeared in the string lp &lt;- length(str_extract_all(i$password, i$character)[[1]]) # check to see if the password is valid i$min &lt;= lp &amp; lp &lt;= i$max } input %&gt;% split_input() %&gt;% # run the is_valid function on each of the input values, keeping only the # valid passwords keep(is_valid) %&gt;% # pull out the password value from each of the lists map_chr(&quot;password&quot;) } part_1_valid_passwords(sample) ## 1 3 ## &quot;abcde&quot; &quot;ccccccccc&quot; This matches with the example given on the AOC website. We can now try to solve the first part: length(part_1_valid_passwords(actual)) ## [1] 493 2.2 Part 2 We can use the split_input function again, but modifiy the is_valid function slightly. part_2_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # as per part 1, but this time extract the characters in the password at # position min and max a &lt;- str_sub(i$password, i$min, i$min) == i$character b &lt;- str_sub(i$password, i$max, i$max) == i$character # we can now xor these values: if both a and b are true xor = FASLE xor(a, b) } input %&gt;% split_input() %&gt;% keep(is_valid) %&gt;% map_chr(&quot;password&quot;) } part_2_valid_passwords(sample) ## 1 ## &quot;abcde&quot; This matches the example, so we can now solve part 2. length(part_2_valid_passwords(actual)) ## [1] 593 "],["toboggan-trajectory.html", "Day 3 Toboggan Trajectory 3.1 Part 1 3.2 Part 2 3.3 Extra: Is there a path that minimises the number of trees you encounter?", " Day 3 Toboggan Trajectory This is my attempt to solve Day 3. sample &lt;- read_lines(&quot;samples/day_03_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_03_input.txt&quot;) 3.1 Part 1 I think it will be easier to convert the map to a 0-1 matrix to solve today’s problem. We won’t need to infinitely replicate the pattern to the right as we can just use modular arithmetic to index into the matrix. input_to_matrix &lt;- function(input) { input %&gt;% # extract each character from the input str_extract_all(&quot;.&quot;, simplify = TRUE) %&gt;% # if a value is &quot;#&quot; then TRUE, else FALSE `==`(&quot;#&quot;) %&gt;% # convert the TRUE&#39;s to 1, FALSE&#39;s to 0 apply(c(1,2), as.integer) } sample_matrix &lt;- input_to_matrix(sample) actual_matrix &lt;- input_to_matrix(actual) sample_matrix ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] ## [1,] 0 0 1 1 0 0 0 0 0 0 0 ## [2,] 1 0 0 0 1 0 0 0 1 0 0 ## [3,] 0 1 0 0 0 0 1 0 0 1 0 ## [4,] 0 0 1 0 1 0 0 0 1 0 1 ## [5,] 0 1 0 0 0 1 1 0 0 1 0 ## [6,] 0 0 1 0 1 1 0 0 0 0 0 ## [7,] 0 1 0 1 0 1 0 0 0 0 1 ## [8,] 0 1 0 0 0 0 0 0 0 0 1 ## [9,] 1 0 1 1 0 0 0 1 0 0 0 ## [10,] 1 0 0 0 1 1 0 0 0 0 1 ## [11,] 0 1 0 0 1 0 0 0 1 0 1 Now that we have 0-1 matrices for the sample and actual data, we can consider how to solve the puzzle. For each row that we move down the matrix, we need to move 3 to the right (starting from [1,1]). Now, the pattern repeats infinitely to the right; however, we do not need to repeat the matrix at all. We can simply “wrap around” back to 1 when we reach the 12th column. In this case, we want to start from 1, then move 3 to the right to 4, then to 7 and 10. But after that we would land at 13, which is the same as being at position 2. We can achieve this using the “remainder” (%%) operator. This is 0 based however, so we need to subtract 1 from the row number and add 1 at the end: (3 * (1:11 - 1)) %% 11 + 1 ## [1] 1 4 7 10 2 5 8 11 3 6 9 We can now build a function to work out which “trees” we would land on by traversing the matrix. part_1 &lt;- function(input) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in 1:nrow(m)) m[i, (3 * (i - 1)) %% ncol(m) + 1] &lt;- 1 # just standard multiplication, not matrix multiplication sum(input * m) } We can check that this function matches the sample provided: part_1(sample_matrix) == 7 ## [1] TRUE We can now run the part 1 function on the actual data: part_1(actual_matrix) ## [1] 151 3.2 Part 2 We now need to adapt our function from part 1 to work with different step sizes. part_2 &lt;- function(input, down, right) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in seq(1, nrow(m), down)) { # our for loop now skips certain rows, but we need to alter our index to be # based on the current step that we are on: so we divide (i - 1) by the down # step size m[i, (right * (i - 1) / down) %% ncol(m) + 1] &lt;- 1 } # just standard multiplication, not matrix multiplication. because our trees # are encoded by a 1, and the positions we land are encoded by a 1, we will # find the trees that we encounter iff both positions in input and m are 1. # The value in the resultant matrix will be a 1 in those positions, # otherwise 0. We can then simply sum the matrix. sum(input * m) } We can check that this function matches the sample provided: all( part_2(sample_matrix, 1, 1) == 2, part_2(sample_matrix, 1, 3) == 7, part_2(sample_matrix, 1, 5) == 3, part_2(sample_matrix, 1, 7) == 4, part_2(sample_matrix, 2, 1) == 2 ) ## [1] TRUE We can now run the part 1 function on the actual data: prod( part_2(actual_matrix, 1, 1), part_2(actual_matrix, 1, 3), part_2(actual_matrix, 1, 5), part_2(actual_matrix, 1, 7), part_2(actual_matrix, 2, 1) ) ## [1] 7540141059 3.3 Extra: Is there a path that minimises the number of trees you encounter? First, let’s define some additional constraints. We must consider movements that are unique; for instance, going 2 down and 2 right is the same as 1 down, 1 right. In this case we will only check 1 down and 1 right. We also know that going 0 to the right is the same as going the number of columns to the right. So, we consider a maximum step right that is 1 less than the number of columns. Likewise, down must be between 1 and the number of rows. We can run our algorithm for any valid combination of movements down and right that match the constraints above. First, let’s consider what happens when we don’t go right, but we go straight down. part_2(actual_matrix, 1, 0) ## [1] 105 Now, what happens if we always go 1 right? map_dbl(1:nrow(actual_matrix), part_2, input = actual_matrix, right = 1) ## [1] 103 59 29 27 18 13 23 12 10 10 9 9 6 6 6 4 7 3 ## [19] 9 8 8 1 2 3 3 3 2 1 3 7 1 3 2 3 0 1 ## [37] 5 1 4 1 3 1 2 2 2 1 1 3 3 1 1 3 2 0 ## [55] 2 1 1 2 1 2 2 1 2 4 0 2 1 0 1 0 1 0 ## [73] 3 2 2 1 2 1 0 1 2 0 1 2 2 1 0 1 0 1 ## [91] 1 1 1 1 0 0 0 1 1 0 3 0 2 1 1 0 1 1 ## [109] 1 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 ## [127] 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 1 0 ## [145] 1 1 1 0 1 0 0 0 1 0 0 0 1 0 0 1 1 0 ## [163] 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 ## [181] 0 1 0 0 1 0 0 0 0 0 1 0 0 1 0 0 0 1 ## [199] 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 ## [217] 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 ## [235] 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 ## [253] 1 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0 1 ## [271] 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0 ## [289] 1 0 0 0 1 0 0 0 1 0 0 1 0 0 1 1 1 0 ## [307] 1 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 We can see a number of options here where we can get to the bottom without hitting any trees. We can’t get any better than 0, so we may as well give up now rather than try all of the other combinations! The other combinations would be going just 1 down at each step, and then all of the combinations of right and down such that the greatest common divisor of right and down is 1. This would give us all of the movements that don’t violate the constraint above of a non-unique movement. For instance, 6 right, 2 down has a greatest common divisor of 2, and this combination is the same as 3 right, 1 down. "],["passport-processing.html", "Day 4 Passport Processing 4.1 Part 1 4.2 Part 2 4.3 Extra: Solving with regular expressions", " Day 4 Passport Processing This is my attempt to solve Day 4. sample &lt;- read_lines(&quot;samples/day_04_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_04_input.txt&quot;) 4.1 Part 1 The fields for todays puzzle are: byr (Birth Year) iyr (Issue Year) eyr (Expiration Year) hgt (Height) hcl (Hair Color) ecl (Eye Color) pid (Passport ID) cid (Country ID) For a record to be treated as valid we must have all of the fields present, except for the country id which is optional. Records are separated by blank new lines. I am going to first collapse the data into a single string, separated by “,”. The blank lines will then be “,,”, so we can simply split our input there. This will give us one string per records. We then need to sort out each record by splitting each string at either a space or a comma, then using the unglue_data function to extra a data frame with a column “key” for the left hand part and a column “value” for the right hand part. By using map_dfr we will be able to combine each record’s key/value pairs into a single dataframe, but we add a column “record” to keep track of which record we are dealing with. process_data &lt;- function(input) { input %&gt;% paste(collapse = &quot;,&quot;) %&gt;% str_split(&quot;,,&quot;) %&gt;% # take just the first result returned by str_split, it will return a list # with one item which contains the results pluck(1) %&gt;% str_split(&quot;[, ]&quot;) %&gt;% map_dfr(unglue::unglue_data, &quot;{key}:{value}&quot;, .id = &quot;record&quot;) } process_data(sample) ## record key value ## 1 1 ecl gry ## 2 1 pid 860033327 ## 3 1 eyr 2020 ## 4 1 hcl #fffffd ## 5 1 byr 1937 ## 6 1 iyr 2017 ## 7 1 cid 147 ## 8 1 hgt 183cm ## 9 2 iyr 2013 ## 10 2 ecl amb ## 11 2 cid 350 ## 12 2 eyr 2023 ## 13 2 pid 028048884 ## 14 2 hcl #cfa07d ## 15 2 byr 1929 ## 16 3 hcl #ae17e1 ## 17 3 iyr 2013 ## 18 3 eyr 2024 ## 19 3 ecl brn ## 20 3 pid 760753108 ## 21 3 byr 1931 ## 22 3 hgt 179cm ## 23 4 hcl #cfa07d ## 24 4 eyr 2025 ## 25 4 pid 166559648 ## 26 4 iyr 2011 ## 27 4 ecl brn ## 28 4 hgt 59in get_valid_records &lt;- function(input) { input %&gt;% process_data() %&gt;% filter(key != &quot;cid&quot;) %&gt;% group_by(record) %&gt;% filter(n() == 7) %&gt;% ungroup() } part_1 &lt;- function(input) { input %&gt;% get_valid_records() %&gt;% distinct(record) %&gt;% nrow() } We can test our function on the sample: part_1(sample) == 2 ## [1] TRUE Now we can run our function on the actual data: part_1(actual) ## [1] 233 4.2 Part 2 We now need to validate the data in the passports: byr (Birth Year) - four digits; at least 1920 and at most 2002. iyr (Issue Year) - four digits; at least 2010 and at most 2020. eyr (Expiration Year) - four digits; at least 2020 and at most 2030. hgt (Height) - a number followed by either cm or in: If cm, the number must be at least 150 and at most 193. If in, the number must be at least 59 and at most 76. hcl (Hair Color) - a # followed by exactly six characters 0-9 or a-f. ecl (Eye Color) - exactly one of: amb blu brn gry grn hzl oth. pid (Passport ID) - a nine-digit number, including leading zeroes. cid (Country ID) - ignored, missing or not. The approach I am going to take for part 2 is to build some helper validation functions for the years and the height parts of the record, and then filter the rows to just retain valid records. To make it easier to do this I will first pivot the data from long format to wide, so each passport is one row of data. part_2 &lt;- function(input) { validate_years &lt;- function(y, min, max) { yi &lt;- suppressWarnings(as.integer(y)) ifelse(is.na(yi), FALSE, min &lt;= yi &amp; yi &lt;= max) } validate_height &lt;- function(h) { hv &lt;- suppressWarnings(as.integer(str_sub(h, 1, -3))) ht &lt;- str_sub(h, -2, -1) case_when(is.na(hv) ~ FALSE, ht == &quot;cm&quot; ~ 150 &lt;= hv &amp; hv &lt;= 193, ht == &quot;in&quot; ~ 59 &lt;= hv &amp; hv &lt;= 76, TRUE ~ FALSE) } input %&gt;% get_valid_records() %&gt;% pivot_wider(names_from = key, values_from = value) %&gt;% filter(validate_years(byr, 1920, 2002), validate_years(iyr, 2010, 2020), validate_years(eyr, 2020, 2030), validate_height(hgt), str_detect(hcl, &quot;^#[0-9a-f]{6}$&quot;), ecl %in% c(&quot;amb&quot;, &quot;blu&quot;, &quot;brn&quot;, &quot;gry&quot;, &quot;grn&quot;, &quot;hzl&quot;, &quot;oth&quot;), str_detect(pid, &quot;^\\\\d{9}$&quot;)) } The provided test cases don’t use the initial sample data, so let’s just run the function and see if it does not error. part_2(sample) ## # A tibble: 2 x 8 ## record ecl pid eyr hcl byr iyr hgt ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 gry 860033327 2020 #fffffd 1937 2017 183cm ## 2 3 brn 760753108 2024 #ae17e1 1931 2013 179cm It seems to work, so let’s run on our actual data nrow(part_2(actual)) ## [1] 111 4.3 Extra: Solving with regular expressions This could be reduced to simply solving with regular expressions. First let’s create a function to convert the input into a single string. records_as_strings &lt;- function(input) { input %&gt;% str_replace(&quot;^$&quot;, &quot;\\n&quot;) %&gt;% paste(collapse = &quot; &quot;) %&gt;% str_split(&quot; \\n &quot;) %&gt;% pluck(1) } records_as_strings(sample) ## [1] &quot;ecl:gry pid:860033327 eyr:2020 hcl:#fffffd byr:1937 iyr:2017 cid:147 hgt:183cm&quot; ## [2] &quot;iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884 hcl:#cfa07d byr:1929&quot; ## [3] &quot;hcl:#ae17e1 iyr:2013 eyr:2024 ecl:brn pid:760753108 byr:1931 hgt:179cm&quot; ## [4] &quot;hcl:#cfa07d eyr:2025 pid:166559648 iyr:2011 ecl:brn hgt:59in&quot; Now, for part 1 we just need to run a regular expression for each of the different fields on each record. Using map gives us a list for each of the different fields, so we transpose to get the results of the regex’s for each record. We can then flatten these lists and run the all function to check to see if every regex was matched for that record. actual %&gt;% records_as_strings() %&gt;% map(c(&quot;byr&quot;, &quot;iyr&quot;, &quot;eyr&quot;, &quot;hgt&quot;, &quot;hcl&quot;, &quot;ecl&quot;, &quot;pid&quot;), str_detect, string = .) %&gt;% transpose() %&gt;% map_lgl(compose(all, flatten_lgl)) %&gt;% sum() ## [1] 233 Part 2 is similar, but we need to match the value after the field name. actual %&gt;% records_as_strings() %&gt;% map(c(&quot;byr:(19[2-9][0-9]|200[0-2])&quot;, &quot;iyr:20(1[0-9]|20)&quot;, &quot;eyr:20(2[0-9]|30)&quot;, &quot;hgt:(1([5-8][0-9]|9[0-3])cm|(59|6[0-9]|7[0-6])in)&quot;, &quot;hcl:#[0-9a-f]{6}&quot;, &quot;ecl:(amb|blu|brn|gry|grn|hzl|oth)&quot;, &quot;pid:\\\\d{9}(?!\\\\d)&quot;), # negative lookahead: make sure the character that follows the 9th digit is not a digit str_detect, string = .) %&gt;% transpose() %&gt;% map_lgl(compose(all, flatten_lgl)) %&gt;% sum() ## [1] 111 "],["binary-boarding.html", "Day 5 Binary Boarding 5.1 Part 1 5.2 Part 2 5.3 Extra: Solving algebraicly", " Day 5 Binary Boarding This is my attempt to solve Day 5. sample &lt;- read_lines(&quot;samples/day_05_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_05_input.txt&quot;) 5.1 Part 1 Today’s challenge can be solved with a recursive function where at each step we divide the search space in half. The same algorithm (partition()) will work for both the rows and the columns, we just need to adjust the starting point (i) and the min and max values. Because we are dividing the search space in half at each iteration when the min and max values are equal we can simply return either value. The s argument to partition() should be a vector of individual characters, e.g. c(\"a\", \"b\", \"c\"). partition &lt;- function(s, i, min, max) { if (min == max) { return (min) } # what is the distance between min and max? d &lt;- max - min + 1 # find the half way point m &lt;- d %/% 2 # update either the min or max position if (s[[i]] == &quot;F&quot; | s[[i]] == &quot;L&quot;) { max &lt;- max - m } else { min &lt;- min + m } # call partition on the next character partition(s, i + 1, min, max) } We can now build a function to process each string and return the data as a list. process_string &lt;- function(string) { s &lt;- str_extract_all(string, &quot;.&quot;)[[1]] row &lt;- partition(s, 1, 0, 127) col &lt;- partition(s, 8, 0, 7) list( row = row, col = col, seat = row * 8 + col ) } And now we can our function on the sample data. sample %&gt;% map_dfr(process_string) %&gt;% mutate(str = sample, .before = everything()) ## # A tibble: 3 x 4 ## str row col seat ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BFFFBBFRRR 70 7 567 ## 2 FFFBBBFRRR 14 7 119 ## 3 BBFFBBFRLL 102 4 820 This matches the provided example, so we can run the function on our actual data. actual %&gt;% map_dfr(process_string) %&gt;% pull(seat) %&gt;% max() ## [1] 816 5.2 Part 2 For part 2 we can use the same function from part 1 to get the list of seats. Then, we can find the minimum and maximum seat number and create the range of values, then simply find the seat that isn’t in this range. seats &lt;- actual %&gt;% map_dfr(process_string) %&gt;% pull(seat) range &lt;- min(seats):max(seats) range[!range %in% seats] ## [1] 539 5.3 Extra: Solving algebraicly Triangle numbers are defined as: \\[ \\sum_{i=1}^{n} i = \\frac{n(n + 1)}{2} \\] If we were to find the triangle number of the maximum value and subtract the triangle number of one less than the smallest seat that would give us the sum of the seats if all were occupied. So if we simply subtract the sum of the seats this will leave us with the empty seat. triangle_number &lt;- function(n) 0.5 * n * (n + 1) triangle_number(max(seats)) - triangle_number(min(seats) - 1) - sum(seats) ## [1] 539 "],["custom-customs.html", "Day 6 Custom Customs 6.1 Part 1 6.2 Part 2 6.3 Extra: solving part 1 &amp; 2 with set functions", " Day 6 Custom Customs This is my attempt to solve Day 6. load_file &lt;- function(file) { file %&gt;% read_file() %&gt;% # strip windows added carriage returns str_remove_all(&quot;\\r&quot;) %&gt;% # clear trailing whitespace str_trim() %&gt;% # split where we have two new lines str_split(&quot;\\n\\n&quot;) %&gt;% # take only the first results (the input is just one string) pluck(1) %&gt;% # split each result into individual lines str_split(&quot;\\n&quot;) } sample &lt;- load_file(&quot;samples/day_06_sample.txt&quot;) actual &lt;- load_file(&quot;inputs/day_06_input.txt&quot;) 6.1 Part 1 For part 1 I am going to first split each respondents response into the individual answers (str_extract_all()). This will return a list of character vectors, so I will use flatten_chr() to turn these into vectors containing all of the answers for each group as a character vector. Then I can simply take the unique() values and work out the length() of the resulting vector. I tie all of this together with the compose() function from {purrr}: this is similar to %&gt;%, except it chains the functions together before you evaluate them into a single chain. Like mathematical composition, compose() works with the “outer-most” function first, e.g. str_extract_all() runs before flatten_chr(), etc. part_1 &lt;- function(input) { input %&gt;% map_dbl(compose(length, unique, flatten_chr, str_extract_all), &quot;.&quot;) %&gt;% sum() } Now I can check that this function behaves as expected: part_1(sample) == 11 ## [1] TRUE And we can run on our actual data part_1(actual) ## [1] 6273 6.2 Part 2 For part 2 I am going to start as in part 1, split each respondents response into individual answers. But then I will use reduce() to go through pairs of responses at a time and only select the questions which were answered by both as “yes”. We can then simply take the length() of each groups responses. part_2 &lt;- function(input) { input %&gt;% map(str_extract_all, &quot;.&quot;) %&gt;% map(reduce, ~.y[.y %in% .x]) %&gt;% map_dbl(length) %&gt;% sum() } We can test to see if the function works as expected:: part_2(sample) == 6 ## [1] TRUE And run the function on the actual data. part_2(actual) ## [1] 3254 6.3 Extra: solving part 1 &amp; 2 with set functions We could solve part 1 and 2 with the same function. Part 1 is essentially just the union of set’s in each group, whereas part 2 is the intersection of set’s. So we can instead write a function that accepted a set function as an argument, like so: extra &lt;- function(input, fn) { input %&gt;% map(str_extract_all, &quot;.&quot;) %&gt;% map(reduce, fn) %&gt;% map_dbl(length) %&gt;% sum() } We can now check that this new function works as expected: extra(actual, union) == part_1(actual) ## [1] TRUE extra(actual, intersect) == part_2(actual) ## [1] TRUE "],["handy-haversacks.html", "Day 7 Handy Haversacks 7.1 Part 1 7.2 Part 2 7.3 Extra: alternative solution to part 2", " Day 7 Handy Haversacks This is my attempt to solve Day 7. sample &lt;- read_lines(&quot;samples/day_07_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_07_input.txt&quot;) 7.1 Part 1 I think today’s problem is naturally solved with using graph’s, so I’m going to use the {igraph} package. The easiest way to create a graph is to first create a data frame that contains the columns from and to that indicate which edges are in the graph. Any additional columns will be added as properties to the edge. convert_input_to_tibble &lt;- function(input) { input %&gt;% # we don&#39;t need to keep the word&#39;s &quot;bag&quot; or &quot;bags&quot;. In our data these words # always have a space before, and sometimes have a &quot;.&quot; at the end. We can # use the following regex to remove these words str_remove_all(&quot; bags?\\\\.?&quot;) %&gt;% # we can now split our data at the word &quot;contains&quot; unglue_data(&quot;{from} contain {contains}&quot;) %&gt;% # now we can split the contains column by comma&#39;s mutate(across(contains, str_split, &quot;, &quot;)) %&gt;% # and expand the nested &quot;contains&quot; column unnest_longer(contains) %&gt;% # handle edge case: if the string is no other need to insert a 0 at the start mutate(across(contains, ~if_else(.x == &quot;no other&quot;, &quot;0 no other&quot;, .x))) %&gt;% # now we can split the contains column into the &quot;n&quot; part and the &quot;to&quot; part separate(contains, c(&quot;n&quot;, &quot;to&quot;), &quot;(?&lt;=\\\\d) &quot;, convert = TRUE) %&gt;% # reorder the columns select(from, to, n) } sample_df &lt;- convert_input_to_tibble(sample) actual_df &lt;- convert_input_to_tibble(actual) sample_df ## # A tibble: 15 x 3 ## from to n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 light red bright white 1 ## 2 light red muted yellow 2 ## 3 dark orange bright white 3 ## 4 dark orange muted yellow 4 ## 5 bright white shiny gold 1 ## 6 muted yellow shiny gold 2 ## 7 muted yellow faded blue 9 ## 8 shiny gold dark olive 1 ## 9 shiny gold vibrant plum 2 ## 10 dark olive faded blue 3 ## 11 dark olive dotted black 4 ## 12 vibrant plum faded blue 5 ## 13 vibrant plum dotted black 6 ## 14 faded blue no other 0 ## 15 dotted black no other 0 We can create a graph using the graph_from_data_frame() function: sample_g &lt;- graph_from_data_frame(sample_df) sample_g ## IGRAPH 9df1a03 DN-- 10 15 -- ## + attr: name (v/c), n (e/n) ## + edges from 9df1a03 (vertex names): ## [1] light red -&gt;bright white light red -&gt;muted yellow ## [3] dark orange -&gt;bright white dark orange -&gt;muted yellow ## [5] bright white-&gt;shiny gold muted yellow-&gt;shiny gold ## [7] muted yellow-&gt;faded blue shiny gold -&gt;dark olive ## [9] shiny gold -&gt;vibrant plum dark olive -&gt;faded blue ## [11] dark olive -&gt;dotted black vibrant plum-&gt;faded blue ## [13] vibrant plum-&gt;dotted black faded blue -&gt;no other ## [15] dotted black-&gt;no other and visualise this graph using {igraph}: ggraph(sample_g, layout = &quot;igraph&quot;, algorithm = &quot;nicely&quot;) + geom_edge_link(aes(label = n), angle_calc = &quot;along&quot;, label_dodge = unit(2.5, &quot;mm&quot;), arrow = arrow(length = unit(3, &quot;mm&quot;)), end_cap = circle(10, &quot;mm&quot;)) + geom_node_label(aes(label = str_replace(name, &quot; &quot;, &quot;\\n&quot;))) Our challenge is to find all of the vertices that have a path in to “shiny gold”. The subcomponent() function can tell us all of the vertices in a graph which reach a given vertex. We can simply take the length of this subcomponent and subtract 1 (as the subcomponent includes “shiny gold”). length(subcomponent(sample_g, &quot;shiny gold&quot;, &quot;in&quot;)) - 1 == 4 ## [1] TRUE We now just need to solve for the actual data. actual_g &lt;- graph_from_data_frame(actual_df) length(subcomponent(actual_g, &quot;shiny gold&quot;, &quot;in&quot;)) - 1 ## [1] 278 7.2 Part 2 Part 2 sounds like a recursive function. We can first find the subgraph that includes all of the vertices from “shiny gold”. We can then convert this graph to an adjacency matrix and iterate through each vertex, recursively calling a function that sums how many bags this bag will contain. part_2 &lt;- function(input) { sg &lt;- induced_subgraph(input, subcomponent(input, &quot;shiny gold&quot;, &quot;out&quot;)) am &lt;- as_adjacency_matrix(sg, attr = &quot;n&quot;, sparse = FALSE) fn &lt;- function(am, v = &quot;shiny gold&quot;, n = 1) { a &lt;- am[v, ] * n a &lt;- a[a &gt; 0] # keep as separate step, otherwise can end up with just scalar # now, iterate over each item in a and recursively call this function sum(map_dbl(names(a), ~fn(am, .x, a[[.x]]))) + sum(a) } # call this function on the base case fn(am) } We can test that our function works against the sample case: part_2(sample_g) == 32 ## [1] TRUE A second sample is provided, so we can test against that also: c(&quot;shiny gold bags contain 2 dark red bags.&quot;, &quot;dark red bags contain 2 dark orange bags.&quot;, &quot;dark orange bags contain 2 dark yellow bags.&quot;, &quot;dark yellow bags contain 2 dark green bags.&quot;, &quot;dark green bags contain 2 dark blue bags.&quot;, &quot;dark blue bags contain 2 dark violet bags.&quot;, &quot;dark violet bags contain no other bags.&quot;) %&gt;% convert_input_to_tibble() %&gt;% graph_from_data_frame() %&gt;% part_2() == 126 ## [1] TRUE Now we can run against the actual data: part_2(actual_g) ## [1] 45157 7.3 Extra: alternative solution to part 2 We could also solve part 2 by iterating through each vertex and finding the incident edges and adjacent vertices. We multiply the edge weight (ie$n) by the current value of n, sum these values and add n back in to the total. This gives us the total number of bags, including the initial bag, so we need to subtract 1 from this answer. part_2_alt &lt;- function(g, v, n) { ie &lt;- incident_edges(g, v, &quot;out&quot;)[[1]] vn &lt;- ends(g, ie)[, 2] sum(map2_dbl(vn, ie$n * n, part_2_alt, g = g)) + n } We can now verify that this alternative function works as above. part_2_alt(sample_g, &quot;shiny gold&quot;, 1) - 1 == part_2(sample_g) ## [1] TRUE part_2_alt(actual_g, &quot;shiny gold&quot;, 1) - 1 == part_2(actual_g) ## [1] TRUE "],["handheld-halting.html", "Day 8 Handheld Halting 8.1 Part 1 8.2 Part 2 8.3 Extra: update the computer class", " Day 8 Handheld Halting This is my attempt to solve Day 8. sample &lt;- read_lines(&quot;samples/day_08_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_08_input.txt&quot;) 8.1 Part 1 Today I’m going to build an R6 class to handle the state of the computer. Computer &lt;- R6Class( &quot;Computer&quot;, public = list( initialize = function(instructions) { private$instructions &lt;- instructions %&gt;% unglue_data(&quot;{inst} {i}&quot;, convert = TRUE) %&gt;% mutate(c = 0) }, get_accumulator = function() { private$accumulator }, get_instructions_count = function() { sum(private$instructions$c) }, run_next = function() { next_instruction &lt;- private$next_instruction() private$run_instruction(next_instruction$inst, next_instruction$i) invisible(self) }, run_until_repeat = function() { repeat { next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, print = function(...) { i &lt;- private$instructions[private$ptr, ] cat(&quot;Accumulator: &quot;, private$accumulator, &quot;\\n&quot;) cat(&quot;Pointer: &quot;, private$ptr, &quot;\\n&quot;) cat(&quot;Instructions Ran:&quot;, self$get_instructions_count(), &quot;\\n&quot;) cat(&quot;Next Instruction:&quot;, i$inst, &quot; &quot;, sprintf(&quot;%+d&quot;, i$i), &quot; (&quot;, i$c, &quot;)\\n&quot;) } ), private = list( accumulator = 0, ptr = 1, instructions = list(), next_instruction = function() { private$instructions[private$ptr, ] }, run_instruction = function(inst, i) { private$instructions[private$ptr, &quot;c&quot;] &lt;- 1 + private$instructions[private$ptr, &quot;c&quot;] private$ptr &lt;- private[[inst]](i) }, # instruction functions: must return the next pointer value acc = function(i) { private$accumulator &lt;- private$accumulator + i private$ptr + 1 }, jmp = function(i) { private$ptr + i }, nop = function(i) { private$ptr + 1 } ) ) Now we can initialize our sample computer: sample_computer &lt;- Computer$new(sample) sample_computer ## Accumulator: 0 ## Pointer: 1 ## Instructions Ran: 0 ## Next Instruction: nop +0 ( 0 ) And we can run the next instruction: sample_computer$run_next() sample_computer ## Accumulator: 0 ## Pointer: 2 ## Instructions Ran: 1 ## Next Instruction: acc +1 ( 0 ) We can run the computer until we repeat an instruction: sample_computer$run_until_repeat() sample_computer ## Accumulator: 5 ## Pointer: 2 ## Instructions Ran: 7 ## Next Instruction: acc +1 ( 1 ) According to the days text, the accumulator should be 5, and we should have run 7 instructions, which we can see is the output from the sample_computer. Now we can run the actual data: actual_computer &lt;- Computer$new(actual) actual_computer$run_until_repeat() actual_computer ## Accumulator: 1816 ## Pointer: 580 ## Instructions Ran: 211 ## Next Instruction: jmp -101 ( 1 ) 8.2 Part 2 We need to modify our computer slightly. First, we need to introduce a way to see if our computer has halted, which will be when the pointer has exceeded the length of the instructions. Second, we need to be able to flip nop to jmp and jmp to nop. There may be a smarter way to figure out which to flip, but I’m just going to iterate through the initial input and flip one at a time. If the computer halt’s then we have found our solution. Rather than recreating the Computer class, we can use Computer$set() to add a halted method and a run_until_halted_or_repeat method. Computer$set(&quot;public&quot;, &quot;is_halted&quot;, function() { private$ptr &gt; nrow(private$instructions) }) Computer$set(&quot;public&quot;, &quot;run_until_halted_or_repeat&quot;, function() { repeat { if (self$is_halted()) { break() } next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }) Now we need to build a function to take our list of instructions and flip all of the nop/jmp instructions: flip_instructions &lt;- function(input) { input %&gt;% str_detect(&quot;^(?!acc)&quot;) %&gt;% which() %&gt;% map(function(.x) { ix &lt;- input[[.x]] str_sub(input[[.x]], 1, 3) &lt;- if(str_sub(input[[.x]], 1, 3) == &quot;nop&quot;) { &quot;jmp&quot; } else { &quot;nop&quot; } input }) } Our sample flipped looks like this: flip_instructions(sample) ## [[1]] ## [1] &quot;jmp +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[2]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;nop +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[3]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;nop -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[4]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;nop -4&quot; &quot;acc +6&quot; We have 4 set’s of instructions to test. This isn’t the most efficient way of solving this… we could flip each of the instructions in turn, and run the computer on that. This would allow us to exit early. But I don’t think that this will cause us much issues as our actual input isn’t huge (length(actual) instructions). Now we just need to build a function to iterate over the flipped instructions and run until we find a solution, and return the results of that computer. part_2 &lt;- function(input) { for (i in flip_instructions(input)) { computer &lt;- Computer$new(i) computer$run_until_halted_or_repeat() if (computer$is_halted()) { return(list(input = input, computer = computer)) } } stop(&quot;No solution found!&quot;) } part_2(sample) ## $input ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## $computer ## Accumulator: 8 ## Pointer: 10 ## Instructions Ran: 6 ## Next Instruction: NA NA ( NA ) This is the result that we are expecting, so we can run this for the actual data: part_2(actual)$computer ## Accumulator: 1149 ## Pointer: 627 ## Instructions Ran: 123 ## Next Instruction: NA NA ( NA ) 8.3 Extra: update the computer class Redefining the entire class to include the added methods in part 2, and to redefine the print method Computer &lt;- R6Class( &quot;Computer&quot;, public = list( initialize = function(instructions) { private$instructions &lt;- instructions %&gt;% unglue_data(&quot;{inst} {i}&quot;, convert = TRUE) %&gt;% mutate(c = 0) }, get_accumulator = function() { private$accumulator }, get_instructions_count = function() { sum(private$instructions$c) }, run_next = function() { next_instruction &lt;- private$next_instruction() private$run_instruction(next_instruction$inst, next_instruction$i) invisible(self) }, run_until_repeat = function() { repeat { next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, is_halted = function() { private$ptr &gt; nrow(private$instructions) }, run_until_halted_or_repeat = function() { repeat { if (self$is_halted()) { break() } next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, print = function(...) { cat(&quot;Accumulator: &quot;, private$accumulator, &quot;\\n&quot;) cat(&quot;Pointer: &quot;, private$ptr, &quot;\\n&quot;) cat(&quot;Instructions Ran:&quot;, self$get_instructions_count(), &quot;\\n&quot;) cat(&quot;Next Instruction: &quot;) if (self$is_halted()) { cat(&quot;HALTED\\n&quot;) } else { i &lt;- private$instructions[private$ptr, ] cat(i$inst, &quot; &quot;, sprintf(&quot;%+d&quot;, i$i), &quot; (&quot;, i$c, &quot;)\\n&quot;) } } ), private = list( accumulator = 0, ptr = 1, instructions = list(), next_instruction = function() { private$instructions[private$ptr, ] }, run_instruction = function(inst, i) { private$instructions[private$ptr, &quot;c&quot;] &lt;- 1 + private$instructions[private$ptr, &quot;c&quot;] private$ptr &lt;- private[[inst]](i) }, # instruction functions: must return the next pointer value acc = function(i) { private$accumulator &lt;- private$accumulator + i private$ptr + 1 }, jmp = function(i) { private$ptr + i }, nop = function(i) { private$ptr + 1 } ) ) "],["encoding-error.html", "Day 9 Encoding Error 9.1 Part 1 9.2 Part 2", " Day 9 Encoding Error This is my attempt to solve Day 9. sample &lt;- read_lines(&quot;samples/day_09_sample.txt&quot;) %&gt;% as.numeric() actual &lt;- read_lines(&quot;inputs/day_09_input.txt&quot;) %&gt;% as.numeric() 9.1 Part 1 We can solve part 1 by creating a function that slides a window (r) across the input and checks to see if the value of the element i just after the end of the current window, minus all of the values in that window, is in the window. part_1 &lt;- function(input, n) { i &lt;- n + 1 r &lt;- 1:n while (any((input[[i]] - input[r]) %in% input[r])) { r &lt;- r + 1 i &lt;- i + 1 } input[[i]] } We can now check our function gives us the right answer for the sample: ps1 &lt;- part_1(sample, 5) ps1 == 127 ## [1] TRUE This gives us the correct answer, so we can now run on the actual input: pa1 &lt;- part_1(actual, 25) pa1 ## [1] 57195069 9.2 Part 2 The naive approach here is to start to use nested for loops to sum the values. There is probably a smarter way of solving this, but it’s the approach I will use. Instead of using the sum, min and max functions available in R I am going to keep track of the values: this should give us a slight performance boost by not having to iterate through all of the values each time. part_2 &lt;- function(input, t) { s &lt;- which(input == t) # we need to loop until just before the index of the target in the input # as we are using nested loops it should be s - 2 here for (i in 1:(s - 2)) { sv &lt;- input[[i]] # keep track of the sum minv &lt;- sv # and the min value maxv &lt;- sv # and the max value # now we need to loop from the next value (i + 1) to just before the target for (j in (i + 1):(s - 1)) { # update the sum sv &lt;- sv + input[[j]] # if we exceed the target then break out the loop and move to the next i if (sv &gt; t) next() # update the min and max values if (input[[j]] &lt; minv) minv &lt;- input[[j]] if (input[[j]] &gt; maxv) maxv &lt;- input[[j]] # if our sum is equal to the target, then return the sum of the min and # max value if (sv == t) return (minv + maxv) } } } We can test on the sample: part_2(sample, ps1) == 62 ## [1] TRUE And run on the actual input: part_2(actual, pa1) ## [1] 7409241 "],["adapter-array.html", "Day 10 Adapter Array 10.1 Part 1 10.2 Part 2", " Day 10 Adapter Array This is my attempt to solve Day 10. sample &lt;- read_lines(&quot;samples/day_10_sample.txt&quot;) %&gt;% as.numeric() actual &lt;- read_lines(&quot;inputs/day_10_input.txt&quot;) %&gt;% as.numeric() 10.1 Part 1 We can solve part 1 pretty easily using base R functions. First, sort the input. We can then use diff() to calculate the differences between each successive pairs of values, then we can use table() to count how many of each value appears. We can then multiply the values using the prod() (product) function. We just need to remember to add “0” to our input, and the value that is 3 greater than the maximum value in the input. part_1 &lt;- function(input) { c(0, input, max(input + 3)) %&gt;% sort() %&gt;% diff() %&gt;% table() %&gt;% prod() } We can now test our function on the sample: part_1(sample) == 22 * 10 ## [1] TRUE And we can run the function with the actual data: part_1(actual) ## [1] 2475 10.2 Part 2 Part 2 can be solved with Dynamic Programming. We will start at the beginning of the sorted input, and iterate over each item in turn. At each item we find which other items can be reached and increase their counts by the current items count. Once we reach the end of the list we have the answer. part_2 &lt;- function(input) { # ensure input is sorted input &lt;- sort(input) # create a list of values for our counts, initialise to 0 t &lt;- rep(0, length(input)) # set all of the items that can be reached from &quot;0&quot; to 1 t[input &lt;= 3] &lt;- 1 # iterate over the input for (i in seq_along(input)) { # get the current item in the input x &lt;- input[[i]] # get the indexes of the items that can be reached from the current item r &lt;- input &gt; x &amp; input &lt;= x + 3 # update the items that can be reached t[r] &lt;- t[[i]] + t[r] } # return just the final value tail(t, 1) } We can test our part 2 function on the sample data: part_2(sample) == 19208 ## [1] TRUE We know that the actual solution will be a giant number, so make sure R doesn’t format the number in scientific notation by setting the scipen option. options(scipen = 999) part_2(actual) ## [1] 442136281481216 "],["seating-system.html", "Day 11 Seating System 11.1 Part 1 11.2 Part 2 11.3 Solving faster", " Day 11 Seating System This is my attempt to solve Day 11. sample &lt;- read_lines(&quot;samples/day_11_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_11_input.txt&quot;) 11.1 Part 1 We are given that in our input: . is the floor L is an empty seat # is an occupied seat It will make our life simpler to add a border of empty seats round our inputs, and convert the input to a matrix of individual characters process_input &lt;- function(input) { dl &lt;- paste(rep(&quot;.&quot;, str_length(input[[1]])), collapse = &quot;&quot;) m &lt;- paste0(&quot;.&quot;, c(dl, input, dl), &quot;.&quot;) %&gt;% str_extract_all(&quot;.&quot;, simplify = TRUE) # give this matrix an s3 class of &quot;day11&quot; structure(m, class = c(&quot;day11&quot;, class(m))) } # implement a print method for our day11 class print.day11 &lt;- function(x, ...) { cat(paste(apply(x, 1, paste, collapse = &quot;&quot;), collapse = &quot;\\n&quot;), &quot;\\n&quot;) } psample &lt;- process_input(sample) pactual &lt;- process_input(actual) We can now have a quick look at our sample input: psample ## ............ ## .L.LL.LL.LL. ## .LLLLLLL.LL. ## .L.L.L..L... ## .LLLL.LL.LL. ## .L.LL.LL.LL. ## .L.LLLLL.LL. ## ...L.L...... ## .LLLLLLLLLL. ## .L.LLLLLL.L. ## .L.LLLLL.LL. ## ............ Now we can build a function to run n iteration’s: p1_run_iterations &lt;- function(input, n = 1, count = 0) { # this is a recursive function, when n is less than 1 stop iterating and # return whatever input is given if (n &lt; 1) return (list(input = input, count = count)) # take a copy of the current state - we will modify this copied state and # return it for the next iteration next_state &lt;- input for (r in 2:(nrow(input) - 1)) { for (c in 2:(ncol(input) - 1)) { # skip this cell if it&#39;s a . if (input[r, c] == &quot;.&quot;) next() # get adjacent seats adjacent &lt;- c(input[r - 1, c - 1], input[r - 1, c ], input[r - 1, c + 1], input[r , c - 1], input[r , c + 1], input[r + 1, c - 1], input[r + 1, c ], input[r + 1, c + 1]) # count how many are occupied occupied &lt;- sum(ifelse(adjacent == &quot;#&quot;, 1, 0)) if (input[r, c] == &quot;L&quot;) { if (occupied == 0) { next_state[r, c] &lt;- &quot;#&quot; } } else { # it can only be &quot;#&quot; now if (occupied &gt;= 4) { next_state[r, c] &lt;- &quot;L&quot; } } } } if (all(next_state == input)) { return (list(input = input, count = count)) } # run the next itertion, decreasing n by 1 p1_run_iterations(next_state, n - 1, count + 1) } We can now test our function runs as expected on the sample. p1_run_iterations(psample) ## $input ## ............ ## .#.##.##.##. ## .#######.##. ## .#.#.#..#... ## .####.##.##. ## .#.##.##.##. ## .#.#####.##. ## ...#.#...... ## .##########. ## .#.######.#. ## .#.#####.##. ## ............ ## ## $count ## [1] 1 p1_run_iterations(psample, 2) ## $input ## ............ ## .#.LL.L#.##. ## .#LLLLLL.L#. ## .L.L.L..L... ## .#LLL.LL.L#. ## .#.LL.LL.LL. ## .#.LLLL#.##. ## ...L.L...... ## .#LLLLLLLL#. ## .#.LLLLLL.L. ## .#.#LLLL.##. ## ............ ## ## $count ## [1] 2 These match the examples, we just need to check it terminates correctly: p1s &lt;- p1_run_iterations(psample, Inf) p1s$count == 5 ## [1] TRUE We just need a way to count the seats occupied now: count_seats &lt;- function(x) { sum(x$input == &quot;#&quot;) } Which we can run on the variable p1s from above: count_seats(p1s) == 37 ## [1] TRUE While this does run, it’s not particular fast on the actual data. We come back to part 1 later. # disabled chunk pactual %&gt;% p1_run_iterations(Inf) %&gt;% count_seats() 11.2 Part 2 We now need to modify our run iterations function. I am going to embed a function that will search for the first seat, and update the tolerance from 4 to 5. In order to speed up computation we first calculate the “first seat” found from any position. In order to remember these seats we switch from a recursive function to use a loop. Otherwise, the function remains the same as in part 1. p2_run_iterations &lt;- function(input, n) { # create a function to find the first seat that can be seen from r, c in the # direction rd, cd. rd / cd should be 1, -1 or 0, but both should not be 0 find_first_seat &lt;- function(r, c, rd, cd) { rr &lt;- r cc &lt;- c if (input[rr, cc] == &quot;.&quot;) { # return a cell that will be a &quot;.&quot; return (c(1, 1)) } repeat { rr &lt;- rr + rd cc &lt;- cc + cd if (rr &lt; 1 | rr &gt; nrow(input) | cc &lt; 1 | cc &gt; ncol(input) ) { # return a cell that will be a &quot;.&quot; return (c(1, 1)) } else if (input[rr, cc] != &quot;.&quot;) { # return the indexes return (c(rr, cc)) } } } first_seats &lt;- map(2:(nrow(input) - 1), function(r) { map(2:(ncol(input) - 1), function(c) { list( rd = c(-1, -1, -1, 0, 0, 1, 1, 1), cd = c(-1, 0, 1, -1, 1, -1, 0, 1) ) %&gt;% pmap(find_first_seat, r = r, c = c) %&gt;% discard(compose(any, is.na)) }) }) count &lt;- 0 state &lt;- input while (count &lt; n) { # take a copy of the current state - we will modify this copied state and # return it for the next iteration next_state &lt;- state for (r in 2:(nrow(state) - 1)) { for (c in 2:(ncol(state) - 1)) { # skip this cell if it&#39;s a . if (state[r, c] == &quot;.&quot;) next() # our first seats only iterated over the &quot;inside&quot; range, so we need to # subtract 1 from the r and c index adjacent &lt;- map_chr(first_seats[[r - 1]][[c - 1]], ~state[.x[[1]], .x[[2]]]) # count how many are occupied occupied &lt;- sum(adjacent == &quot;#&quot;) if (state[r, c] == &quot;L&quot;) { if (occupied == 0) { next_state[r, c] &lt;- &quot;#&quot; } } else { # it can only be &quot;#&quot; now if (occupied &gt;= 5) { next_state[r, c] &lt;- &quot;L&quot; } } } } if (all(next_state == state)) { break() } state &lt;- next_state count &lt;- count + 1 } list(input = state, count = count) } We can test our function works as expected after 1 iteration: psample %&gt;% p2_run_iterations(1) ## $input ## ............ ## .#.##.##.##. ## .#######.##. ## .#.#.#..#... ## .####.##.##. ## .#.##.##.##. ## .#.#####.##. ## ...#.#...... ## .##########. ## .#.######.#. ## .#.#####.##. ## ............ ## ## $count ## [1] 1 And after 2 iterations: psample %&gt;% p2_run_iterations(2) ## $input ## ............ ## .#.LL.LL.L#. ## .#LLLLLL.LL. ## .L.L.L..L... ## .LLLL.LL.LL. ## .L.LL.LL.LL. ## .L.LLLLL.LL. ## ...L.L...... ## .LLLLLLLLL#. ## .#.LLLLLL.L. ## .#.LLLLL.L#. ## ............ ## ## $count ## [1] 2 We can use the count_seats() function again to test our new function works: psample %&gt;% p2_run_iterations(Inf) %&gt;% count_seats() == 26 ## [1] TRUE Again, this function runs very slowly on the actual data. # disabled chunk pactual %&gt;% p2_run_iterations(Inf) %&gt;% count_seats() 11.3 Solving faster R is much better at vectorised operations, so if we could reduce the steps to summing matrices our code should run much faster. First, we are to treat our input as a matrix that contains either 0 for an unoccupied seat, 1 for an occupied seat, and NA for the floor. We then create functions for part 1 and for part 2 which returns 8 set’s of indices for the directions that we are to look in for seats. These index sets will be used to return a matrix the same size as the inner part of our matrix (we ignore the border). Part 1’s function is pretty simple, we simply shift the matrix one up, one to the left, then just one up, then one up and one to the right, etc. This function is pretty slow as we have to allocate quite a lot of memory. part_one &lt;- function(input) { nr &lt;- nrow(input) nc &lt;- ncol(input) cross2(1:3, 1:3) %&gt;% discard(~ .x[[1]] == 2 &amp;&amp; .x[[2]] == 2) %&gt;% map(function(.x) { cross_df( list( row = .x[[1]]:(nr - 3 + .x[[1]]), col = .x[[2]]:(nc - 3 + .x[[2]]) ) ) %&gt;% as.matrix() }) } Part 2 is slightly more complex as we need to find the seat according to the more complex rules. part_two &lt;- function(input) { nr &lt;- nrow(input) nc &lt;- ncol(input) find_in_direction &lt;- function(r, c, rd, cd) { ri &lt;- r ci &lt;- c repeat { ri &lt;- ri + rd ci &lt;- ci + cd # we have reached the boundary, exit if (ri &lt; 1 | ri &gt; nr | ci &lt; 1 | ci &gt; nc) { return (list(row = ri - rd, col = ci - cd)) } # we have found a seat, return if (!is.na(input[ri, ci])) { return (list(row = ri, col = ci)) } } } # get the indices of each cell in the inner part of the input matrix ixs &lt;- cross_df(list(r = 2:(nr - 1), c = 2:(nc - 1))) # now find the values in each direction list( pmap_dfr(ixs, find_in_direction, -1, -1), pmap_dfr(ixs, find_in_direction, -1, 0), pmap_dfr(ixs, find_in_direction, -1, 1), pmap_dfr(ixs, find_in_direction, 0, -1), pmap_dfr(ixs, find_in_direction, 0, 1), pmap_dfr(ixs, find_in_direction, 1, -1), pmap_dfr(ixs, find_in_direction, 1, 0), pmap_dfr(ixs, find_in_direction, 1, 1) ) %&gt;% map(as.matrix) } We now create a solving function, which takes the data as the first argument, either part_one() or part_two() as the second argument, and the tolerance (4 for part 1, 5 for part 2). solve &lt;- function(x, add_mat_fn, tolerance) { input &lt;- ifelse(unclass(x) == &quot;L&quot;, 0, NA) nr &lt;- nrow(input) nc &lt;- ncol(input) add_mat_ix &lt;- add_mat_fn(input) repeat { # use this to check later if our matrix has changed t &lt;- input # use our matrix indices, find the values for the 8 shifted matrices, then # add the 8 matrices together to give us one matrix that tells us how many # adjacent seats are occupied add_mat &lt;- add_mat_ix %&gt;% map(~input[.x] %&gt;% replace_na(0) %&gt;% matrix(nrow = nr - 2, ncol = nc - 2)) %&gt;% reduce(`+`) # find the unoccupied seats in the input y &lt;- which(input == 0, arr.ind = TRUE) # and the occupied seats z &lt;- which(input == 1, arr.ind = TRUE) # update the unoccupied seats input[y] &lt;- 1 * (add_mat[y - 1] == 0) # update the occupied seats input[z] &lt;- 1 * (add_mat[z - 1] &lt; tolerance) # check to see if our matrix has changed if (all(t == input, na.rm = TRUE)) break() } # now just return the number of occupied seats sum(input, na.rm = TRUE) } We can now run our new function’s and see if they give us the same results as above: solve(psample, part_one, 4) ## [1] 37 solve(pactual, part_one, 4) ## [1] 2483 solve(psample, part_two, 5) ## [1] 26 solve(pactual, part_two, 5) ## [1] 2285 "]]
