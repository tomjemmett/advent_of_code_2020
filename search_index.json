[["index.html", "Advent of Code 2020 Introduction", " Advent of Code 2020 Tom Jemmett 2020-12-30 Introduction This is my attempt to complete the Advent of Code 2020 in R using RMarkdown, along with bookdown to render the site. The book will automatically be rebuilt using GitHub actions and hosted using GitHub Pages. "],["report-repair.html", "Day 1 Report Repair 1.1 Part 1 1.2 Part 2 1.3 Extra: Implementing in Python", " Day 1 Report Repair This is my attempt to solve Day 1. sample &lt;- read_lines(&quot;samples/day_01_sample.txt&quot;) %&gt;% as.integer() actual &lt;- read_lines(&quot;inputs/day_01_input.txt&quot;) %&gt;% as.integer() 1.1 Part 1 The naive approach to solving today’s problem is to simple loop through the list twice, checking to see if the condition is met. If it is, immediately return that value. If we reach the end of both loops without finding the solution we can return NULL to indicate no result found. part_1_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input)-1)) { for (j in (i+1):length(input)) { if (input[[i]] + input[[j]] == target) return (input[[i]] * input[[j]]) } } NULL } We can test that this method works: part_1_naive(sample, 2020) == 514579 ## [1] TRUE This approach could be improved, we can sort the list, then create two pointers: the start and end of the list. If we add these two numbers up and exceed the target then we can decrease the higher number pointer. If the number is lower that the target we increase the lower number pointer. part_1_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) i &lt;- 1 j &lt;- length(input) input &lt;- sort(input) while (i &lt;= j) { v &lt;- input[[i]] + input[[j]] if (v == target) { return (input[[i]] * input[[j]]) } else if (v &lt; target) { i &lt;- i + 1 } else { j &lt;- j - 1 } } NULL } Again, we can test that this method works. part_1_improved(sample, 2020) == 514579 ## [1] TRUE We can now use our improved algorithm to get the result for part 1: part_1_improved(actual, 2020) ## [1] 793524 1.1.1 is the improved algorithm any better? bench::mark(part_1_naive(sample, 2020), part_1_improved(sample, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(sample, 2020) 3.07µs 3.61µs 247119. 0B 24.7 ## 2 part_1_improved(sample, 2020) 57.25µs 65.73µs 15020. 0B 17.0 For me, the improved algorithm actually takes longer on the sample data! This is because the improved algorithm has to sort the data, which is costly, and then it performs far more comparisons per iteration. However, when we have more data, these extra steps lead to big improvements, as can be seen when running with the actual data. bench::mark(part_1_naive(actual, 2020), part_1_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_1_naive(actual, 2020) 680.8µs 711µs 1367. 0B 2.02 ## 2 part_1_improved(actual, 2020) 84.6µs 91.5µs 7968. 1.66KB 10.6 The improved algorithm was roughly 10x faster for me on the actual data. 1.2 Part 2 We can alter the naive approach from part 1 by adding in an extra for loop. part_2_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input) - 2)) { for (j in (i + 1):(length(input) - 1)) { for (k in (j + 1):length(input)) { if (input[[i]] + input[[j]] + input[[k]] == target) return (prod(input[c(i, j, k)])) } } } NULL } Again, we can test that this method works on the sample. part_2_naive(sample, 2020) == 241861950 ## [1] TRUE It’s much harder to adapt the improved algorithm though. My best approach involves a binary search. This function takes a sorted array, a target value, a current index into the array, and the current min/max extents to search. If the value at position i in array is less than target, we look in the left half of the array, chopping it in half by reducing max. Likewise, if the value is greater than target, we look in the right half of the array, chopping it in half by increasing min. binary_search &lt;- function(arr, target, i, min, max) { if (arr[[i]] == target) { return(i) } else if (target &lt; arr[[i]]) { max &lt;- i ni &lt;- (min + i) %/% 2 } else { min &lt;- i ni &lt;- (max + i) %/% 2 } if (ni == i) { NULL } else { binary_search(arr, target, ni, min, max) } } Our improved algorithm for part 2 involves creating two for loops to search from the end of the (sorted) input. We then remove the third loop by using a binary search to find the target value quicker. In the two for loops we first calculate the value of the adding these two items together, quickly checking to see if there is a possible solution (and exiting early if not). Then, we perform a binary search on the rest of the array for the amount required to make v equal target (2020). If we find the value, then we simply return the results. Else we continue the search by looping. part_2_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) input &lt;- sort(input) for (j in length(input):3) { for (i in (j - 1):2) { v &lt;- sum(input[c(i, j)]) # early termination if (v &gt;= target) next() if (v + input[[i - 1]] &lt; target) next() # binary search for a suitable value k &lt;- binary_search(input, target - v, (i + 1) %/% 2, 1, (i - 1)) if (!is.null(k)) { return (prod(input[c(i, j, k)])) } } } NULL } We can once again test that our method works on the sample data: part_2_improved(sample, 2020) == 241861950 ## [1] TRUE We can now run both approaches to see what the result is: part_2_naive(actual, 2020) ## [1] 61515678 part_2_improved(actual, 2020) ## [1] 61515678 1.2.1 Is our improved algorithm better this time? Once again, we can benchmark the two approaches. bench::mark(part_2_naive(actual, 2020), part_2_improved(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_2_naive(actual, 2020) 110ms 111.6ms 8.95 0B 5.96 ## 2 part_2_improved(actual, 2020) 15ms 15.3ms 65.5 1.66KB 377. On my machine the improved approach is again about 10x quicker. 1.3 Extra: Implementing in Python I wanted to have a go at implementing my improved algorithm in python, but we can take advantage of sets to get even better performance and do away with the need to sort the list and perform binary search (asking if a value is in a set is a constant time operation in python - it’s near instantaneous). library(reticulate) def part_2_py(input_values, target): # convert the s = { i for i in input_values } # outer loop: we need to have at least 3 items to check while len(s) &gt; 2: # remove a value from the set j = s.pop() # take a copy of the set: if we don&#39;t find a solution for j then we need to # continue with the set as it was at this point t = s.copy() while len(t) &gt; 1: # remove a value from the copied set i = t.pop() # the value to reach the target k = target - i - j # is k in the set? I.e. does i + j + k == target? if k in t: return i * j * k # no solution, return none return none bench::mark(part_2_improved(actual, 2020), py$part_2_py(actual, 2020)) ## # A tibble: 2 x 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 part_2_improved(actual, 2020) 14.38ms 15.29ms 65.2 1.66KB 37.7 ## 2 py$part_2_py(actual, 2020) 1.21ms 1.29ms 768. 17.45KB 2.02 "],["password-philosophy.html", "Day 2 Password Philosophy 2.1 Part 1 2.2 Part 2", " Day 2 Password Philosophy This is my attempt to solve Day 2. sample &lt;- read_lines(&quot;samples/day_02_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_02_input.txt&quot;) 2.1 Part 1 We need to convert each string into a list that contains the following: minimum number of occurrences of the character maximum number of occurrences of the character the character that must be present the password Originally, I wrote the following function to handle this step: split_input &lt;- function(input) { input %&gt;% # first, split the string into the bit before the password, and the password str_split(&quot;: &quot;) %&gt;% # now, we can iterate over the results (each line of data) map(function(.x) { # find the min/max values from the first part of the input string .x mv &lt;- .x[[1]] %&gt;% # we can remove the last 2 characters of the string (the character) str_sub(1, -3) %&gt;% # now we can split the string into the min and max values str_split(&quot;-&quot;) %&gt;% # str_split is vectorised, but we only want the first results as we are # dealing with one line at a time: # the first result will contain two values pluck(1) %&gt;% # now convert these to integers as.integer() # we can now return the results list( min = mv[[1]], max = mv[[2]], character = str_sub(.x[[1]], -1, -1), password = .x[[2]] ) }) } But, after seeing a post by @antoine_fabri on Twitter I discovered the {unglue} package which makes this much easier, and neater! split_input &lt;- function(input) { unglue::unglue(input, &quot;{min}-{max} {character}: {password}&quot;, convert = TRUE) } We can see what our split_input function does to the sample data, looking at just the first item str(split_input(sample)[[1]]) ## &#39;data.frame&#39;: 1 obs. of 4 variables: ## $ min : int 1 ## $ max : int 3 ## $ character: chr &quot;a&quot; ## $ password : chr &quot;abcde&quot; Now we can build a function to return the valid passwords. part_1_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # extract the matching values from the string, we can then count the size of # the vector to find how many times that character appeared in the string lp &lt;- length(str_extract_all(i$password, i$character)[[1]]) # check to see if the password is valid i$min &lt;= lp &amp; lp &lt;= i$max } input %&gt;% split_input() %&gt;% # run the is_valid function on each of the input values, keeping only the # valid passwords keep(is_valid) %&gt;% # pull out the password value from each of the lists map_chr(&quot;password&quot;) } part_1_valid_passwords(sample) ## 1 3 ## &quot;abcde&quot; &quot;ccccccccc&quot; This matches with the example given on the AOC website. We can now try to solve the first part: length(part_1_valid_passwords(actual)) ## [1] 493 2.2 Part 2 We can use the split_input function again, but modifiy the is_valid function slightly. part_2_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # as per part 1, but this time extract the characters in the password at # position min and max a &lt;- str_sub(i$password, i$min, i$min) == i$character b &lt;- str_sub(i$password, i$max, i$max) == i$character # we can now xor these values: if both a and b are true xor = FASLE xor(a, b) } input %&gt;% split_input() %&gt;% keep(is_valid) %&gt;% map_chr(&quot;password&quot;) } part_2_valid_passwords(sample) ## 1 ## &quot;abcde&quot; This matches the example, so we can now solve part 2. length(part_2_valid_passwords(actual)) ## [1] 593 "],["toboggan-trajectory.html", "Day 3 Toboggan Trajectory 3.1 Part 1 3.2 Part 2 3.3 Extra: Is there a path that minimises the number of trees you encounter?", " Day 3 Toboggan Trajectory This is my attempt to solve Day 3. sample &lt;- read_lines(&quot;samples/day_03_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_03_input.txt&quot;) 3.1 Part 1 I think it will be easier to convert the map to a 0-1 matrix to solve today’s problem. We won’t need to infinitely replicate the pattern to the right as we can just use modular arithmetic to index into the matrix. input_to_matrix &lt;- function(input) { input %&gt;% # extract each character from the input str_extract_all(&quot;.&quot;, simplify = TRUE) %&gt;% # if a value is &quot;#&quot; then TRUE, else FALSE `==`(&quot;#&quot;) %&gt;% # convert the TRUE&#39;s to 1, FALSE&#39;s to 0 apply(c(1,2), as.integer) } sample_matrix &lt;- input_to_matrix(sample) actual_matrix &lt;- input_to_matrix(actual) sample_matrix ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] ## [1,] 0 0 1 1 0 0 0 0 0 0 0 ## [2,] 1 0 0 0 1 0 0 0 1 0 0 ## [3,] 0 1 0 0 0 0 1 0 0 1 0 ## [4,] 0 0 1 0 1 0 0 0 1 0 1 ## [5,] 0 1 0 0 0 1 1 0 0 1 0 ## [6,] 0 0 1 0 1 1 0 0 0 0 0 ## [7,] 0 1 0 1 0 1 0 0 0 0 1 ## [8,] 0 1 0 0 0 0 0 0 0 0 1 ## [9,] 1 0 1 1 0 0 0 1 0 0 0 ## [10,] 1 0 0 0 1 1 0 0 0 0 1 ## [11,] 0 1 0 0 1 0 0 0 1 0 1 Now that we have 0-1 matrices for the sample and actual data, we can consider how to solve the puzzle. For each row that we move down the matrix, we need to move 3 to the right (starting from [1,1]). Now, the pattern repeats infinitely to the right; however, we do not need to repeat the matrix at all. We can simply “wrap around” back to 1 when we reach the 12th column. In this case, we want to start from 1, then move 3 to the right to 4, then to 7 and 10. But after that we would land at 13, which is the same as being at position 2. We can achieve this using the “remainder” (%%) operator. This is 0 based however, so we need to subtract 1 from the row number and add 1 at the end: (3 * (1:11 - 1)) %% 11 + 1 ## [1] 1 4 7 10 2 5 8 11 3 6 9 We can now build a function to work out which “trees” we would land on by traversing the matrix. part_1 &lt;- function(input) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in 1:nrow(m)) m[i, (3 * (i - 1)) %% ncol(m) + 1] &lt;- 1 # just standard multiplication, not matrix multiplication sum(input * m) } We can check that this function matches the sample provided: part_1(sample_matrix) == 7 ## [1] TRUE We can now run the part 1 function on the actual data: part_1(actual_matrix) ## [1] 151 3.2 Part 2 We now need to adapt our function from part 1 to work with different step sizes. part_2 &lt;- function(input, down, right) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in seq(1, nrow(m), down)) { # our for loop now skips certain rows, but we need to alter our index to be # based on the current step that we are on: so we divide (i - 1) by the down # step size m[i, (right * (i - 1) / down) %% ncol(m) + 1] &lt;- 1 } # just standard multiplication, not matrix multiplication. because our trees # are encoded by a 1, and the positions we land are encoded by a 1, we will # find the trees that we encounter iff both positions in input and m are 1. # The value in the resultant matrix will be a 1 in those positions, # otherwise 0. We can then simply sum the matrix. sum(input * m) } We can check that this function matches the sample provided: all( part_2(sample_matrix, 1, 1) == 2, part_2(sample_matrix, 1, 3) == 7, part_2(sample_matrix, 1, 5) == 3, part_2(sample_matrix, 1, 7) == 4, part_2(sample_matrix, 2, 1) == 2 ) ## [1] TRUE We can now run the part 1 function on the actual data: prod( part_2(actual_matrix, 1, 1), part_2(actual_matrix, 1, 3), part_2(actual_matrix, 1, 5), part_2(actual_matrix, 1, 7), part_2(actual_matrix, 2, 1) ) ## [1] 7540141059 3.3 Extra: Is there a path that minimises the number of trees you encounter? First, let’s define some additional constraints. We must consider movements that are unique; for instance, going 2 down and 2 right is the same as 1 down, 1 right. In this case we will only check 1 down and 1 right. We also know that going 0 to the right is the same as going the number of columns to the right. So, we consider a maximum step right that is 1 less than the number of columns. Likewise, down must be between 1 and the number of rows. We can run our algorithm for any valid combination of movements down and right that match the constraints above. First, let’s consider what happens when we don’t go right, but we go straight down. part_2(actual_matrix, 1, 0) ## [1] 105 Now, what happens if we always go 1 right? map_dbl(1:nrow(actual_matrix), part_2, input = actual_matrix, right = 1) ## [1] 103 59 29 27 18 13 23 12 10 10 9 9 6 6 6 4 7 3 ## [19] 9 8 8 1 2 3 3 3 2 1 3 7 1 3 2 3 0 1 ## [37] 5 1 4 1 3 1 2 2 2 1 1 3 3 1 1 3 2 0 ## [55] 2 1 1 2 1 2 2 1 2 4 0 2 1 0 1 0 1 0 ## [73] 3 2 2 1 2 1 0 1 2 0 1 2 2 1 0 1 0 1 ## [91] 1 1 1 1 0 0 0 1 1 0 3 0 2 1 1 0 1 1 ## [109] 1 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 ## [127] 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 1 0 ## [145] 1 1 1 0 1 0 0 0 1 0 0 0 1 0 0 1 1 0 ## [163] 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 ## [181] 0 1 0 0 1 0 0 0 0 0 1 0 0 1 0 0 0 1 ## [199] 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 ## [217] 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 ## [235] 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 ## [253] 1 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0 1 ## [271] 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0 ## [289] 1 0 0 0 1 0 0 0 1 0 0 1 0 0 1 1 1 0 ## [307] 1 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 We can see a number of options here where we can get to the bottom without hitting any trees. We can’t get any better than 0, so we may as well give up now rather than try all of the other combinations! The other combinations would be going just 1 down at each step, and then all of the combinations of right and down such that the greatest common divisor of right and down is 1. This would give us all of the movements that don’t violate the constraint above of a non-unique movement. For instance, 6 right, 2 down has a greatest common divisor of 2, and this combination is the same as 3 right, 1 down. "],["passport-processing.html", "Day 4 Passport Processing 4.1 Part 1 4.2 Part 2 4.3 Extra: Solving with regular expressions", " Day 4 Passport Processing This is my attempt to solve Day 4. sample &lt;- read_lines(&quot;samples/day_04_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_04_input.txt&quot;) 4.1 Part 1 The fields for todays puzzle are: byr (Birth Year) iyr (Issue Year) eyr (Expiration Year) hgt (Height) hcl (Hair Color) ecl (Eye Color) pid (Passport ID) cid (Country ID) For a record to be treated as valid we must have all of the fields present, except for the country id which is optional. Records are separated by blank new lines. I am going to first collapse the data into a single string, separated by “,”. The blank lines will then be “,,”, so we can simply split our input there. This will give us one string per records. We then need to sort out each record by splitting each string at either a space or a comma, then using the unglue_data function to extra a data frame with a column “key” for the left hand part and a column “value” for the right hand part. By using map_dfr we will be able to combine each record’s key/value pairs into a single dataframe, but we add a column “record” to keep track of which record we are dealing with. process_data &lt;- function(input) { input %&gt;% paste(collapse = &quot;,&quot;) %&gt;% str_split(&quot;,,&quot;) %&gt;% # take just the first result returned by str_split, it will return a list # with one item which contains the results pluck(1) %&gt;% str_split(&quot;[, ]&quot;) %&gt;% map_dfr(unglue::unglue_data, &quot;{key}:{value}&quot;, .id = &quot;record&quot;) } process_data(sample) ## record key value ## 1 1 ecl gry ## 2 1 pid 860033327 ## 3 1 eyr 2020 ## 4 1 hcl #fffffd ## 5 1 byr 1937 ## 6 1 iyr 2017 ## 7 1 cid 147 ## 8 1 hgt 183cm ## 9 2 iyr 2013 ## 10 2 ecl amb ## 11 2 cid 350 ## 12 2 eyr 2023 ## 13 2 pid 028048884 ## 14 2 hcl #cfa07d ## 15 2 byr 1929 ## 16 3 hcl #ae17e1 ## 17 3 iyr 2013 ## 18 3 eyr 2024 ## 19 3 ecl brn ## 20 3 pid 760753108 ## 21 3 byr 1931 ## 22 3 hgt 179cm ## 23 4 hcl #cfa07d ## 24 4 eyr 2025 ## 25 4 pid 166559648 ## 26 4 iyr 2011 ## 27 4 ecl brn ## 28 4 hgt 59in get_valid_records &lt;- function(input) { input %&gt;% process_data() %&gt;% filter(key != &quot;cid&quot;) %&gt;% group_by(record) %&gt;% filter(n() == 7) %&gt;% ungroup() } part_1 &lt;- function(input) { input %&gt;% get_valid_records() %&gt;% distinct(record) %&gt;% nrow() } We can test our function on the sample: part_1(sample) == 2 ## [1] TRUE Now we can run our function on the actual data: part_1(actual) ## [1] 233 4.2 Part 2 We now need to validate the data in the passports: byr (Birth Year) - four digits; at least 1920 and at most 2002. iyr (Issue Year) - four digits; at least 2010 and at most 2020. eyr (Expiration Year) - four digits; at least 2020 and at most 2030. hgt (Height) - a number followed by either cm or in: If cm, the number must be at least 150 and at most 193. If in, the number must be at least 59 and at most 76. hcl (Hair Color) - a # followed by exactly six characters 0-9 or a-f. ecl (Eye Color) - exactly one of: amb blu brn gry grn hzl oth. pid (Passport ID) - a nine-digit number, including leading zeroes. cid (Country ID) - ignored, missing or not. The approach I am going to take for part 2 is to build some helper validation functions for the years and the height parts of the record, and then filter the rows to just retain valid records. To make it easier to do this I will first pivot the data from long format to wide, so each passport is one row of data. part_2 &lt;- function(input) { validate_years &lt;- function(y, min, max) { yi &lt;- suppressWarnings(as.integer(y)) ifelse(is.na(yi), FALSE, min &lt;= yi &amp; yi &lt;= max) } validate_height &lt;- function(h) { hv &lt;- suppressWarnings(as.integer(str_sub(h, 1, -3))) ht &lt;- str_sub(h, -2, -1) case_when(is.na(hv) ~ FALSE, ht == &quot;cm&quot; ~ 150 &lt;= hv &amp; hv &lt;= 193, ht == &quot;in&quot; ~ 59 &lt;= hv &amp; hv &lt;= 76, TRUE ~ FALSE) } input %&gt;% get_valid_records() %&gt;% pivot_wider(names_from = key, values_from = value) %&gt;% filter(validate_years(byr, 1920, 2002), validate_years(iyr, 2010, 2020), validate_years(eyr, 2020, 2030), validate_height(hgt), str_detect(hcl, &quot;^#[0-9a-f]{6}$&quot;), ecl %in% c(&quot;amb&quot;, &quot;blu&quot;, &quot;brn&quot;, &quot;gry&quot;, &quot;grn&quot;, &quot;hzl&quot;, &quot;oth&quot;), str_detect(pid, &quot;^\\\\d{9}$&quot;)) } The provided test cases don’t use the initial sample data, so let’s just run the function and see if it does not error. part_2(sample) ## # A tibble: 2 x 8 ## record ecl pid eyr hcl byr iyr hgt ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 gry 860033327 2020 #fffffd 1937 2017 183cm ## 2 3 brn 760753108 2024 #ae17e1 1931 2013 179cm It seems to work, so let’s run on our actual data nrow(part_2(actual)) ## [1] 111 4.3 Extra: Solving with regular expressions This could be reduced to simply solving with regular expressions. First let’s create a function to convert the input into a single string. records_as_strings &lt;- function(input) { input %&gt;% str_replace(&quot;^$&quot;, &quot;\\n&quot;) %&gt;% paste(collapse = &quot; &quot;) %&gt;% str_split(&quot; \\n &quot;) %&gt;% pluck(1) } records_as_strings(sample) ## [1] &quot;ecl:gry pid:860033327 eyr:2020 hcl:#fffffd byr:1937 iyr:2017 cid:147 hgt:183cm&quot; ## [2] &quot;iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884 hcl:#cfa07d byr:1929&quot; ## [3] &quot;hcl:#ae17e1 iyr:2013 eyr:2024 ecl:brn pid:760753108 byr:1931 hgt:179cm&quot; ## [4] &quot;hcl:#cfa07d eyr:2025 pid:166559648 iyr:2011 ecl:brn hgt:59in&quot; Now, for part 1 we just need to run a regular expression for each of the different fields on each record. Using map gives us a list for each of the different fields, so we transpose to get the results of the regex’s for each record. We can then flatten these lists and run the all function to check to see if every regex was matched for that record. actual %&gt;% records_as_strings() %&gt;% map(c(&quot;byr&quot;, &quot;iyr&quot;, &quot;eyr&quot;, &quot;hgt&quot;, &quot;hcl&quot;, &quot;ecl&quot;, &quot;pid&quot;), str_detect, string = .) %&gt;% transpose() %&gt;% map_lgl(compose(all, flatten_lgl)) %&gt;% sum() ## [1] 233 Part 2 is similar, but we need to match the value after the field name. actual %&gt;% records_as_strings() %&gt;% map(c(&quot;byr:(19[2-9][0-9]|200[0-2])&quot;, &quot;iyr:20(1[0-9]|20)&quot;, &quot;eyr:20(2[0-9]|30)&quot;, &quot;hgt:(1([5-8][0-9]|9[0-3])cm|(59|6[0-9]|7[0-6])in)&quot;, &quot;hcl:#[0-9a-f]{6}&quot;, &quot;ecl:(amb|blu|brn|gry|grn|hzl|oth)&quot;, &quot;pid:\\\\d{9}(?!\\\\d)&quot;), # negative lookahead: make sure the character that follows the 9th digit is not a digit str_detect, string = .) %&gt;% transpose() %&gt;% map_lgl(compose(all, flatten_lgl)) %&gt;% sum() ## [1] 111 "],["binary-boarding.html", "Day 5 Binary Boarding 5.1 Part 1 5.2 Part 2 5.3 Extra: Solving algebraicly", " Day 5 Binary Boarding This is my attempt to solve Day 5. sample &lt;- read_lines(&quot;samples/day_05_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_05_input.txt&quot;) 5.1 Part 1 Today’s challenge can be solved with a recursive function where at each step we divide the search space in half. The same algorithm (partition()) will work for both the rows and the columns, we just need to adjust the starting point (i) and the min and max values. Because we are dividing the search space in half at each iteration when the min and max values are equal we can simply return either value. The s argument to partition() should be a vector of individual characters, e.g. c(\"a\", \"b\", \"c\"). partition &lt;- function(s, i, min, max) { if (min == max) { return (min) } # what is the distance between min and max? d &lt;- max - min + 1 # find the half way point m &lt;- d %/% 2 # update either the min or max position if (s[[i]] == &quot;F&quot; | s[[i]] == &quot;L&quot;) { max &lt;- max - m } else { min &lt;- min + m } # call partition on the next character partition(s, i + 1, min, max) } We can now build a function to process each string and return the data as a list. process_string &lt;- function(string) { s &lt;- str_extract_all(string, &quot;.&quot;)[[1]] row &lt;- partition(s, 1, 0, 127) col &lt;- partition(s, 8, 0, 7) list( row = row, col = col, seat = row * 8 + col ) } And now we can our function on the sample data. sample %&gt;% map_dfr(process_string) %&gt;% mutate(str = sample, .before = everything()) ## # A tibble: 3 x 4 ## str row col seat ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BFFFBBFRRR 70 7 567 ## 2 FFFBBBFRRR 14 7 119 ## 3 BBFFBBFRLL 102 4 820 This matches the provided example, so we can run the function on our actual data. actual %&gt;% map_dfr(process_string) %&gt;% pull(seat) %&gt;% max() ## [1] 816 5.2 Part 2 For part 2 we can use the same function from part 1 to get the list of seats. Then, we can find the minimum and maximum seat number and create the range of values, then simply find the seat that isn’t in this range. seats &lt;- actual %&gt;% map_dfr(process_string) %&gt;% pull(seat) range &lt;- min(seats):max(seats) range[!range %in% seats] ## [1] 539 5.3 Extra: Solving algebraicly Triangle numbers are defined as: \\[ \\sum_{i=1}^{n} i = \\frac{n(n + 1)}{2} \\] If we were to find the triangle number of the maximum value and subtract the triangle number of one less than the smallest seat that would give us the sum of the seats if all were occupied. So if we simply subtract the sum of the seats this will leave us with the empty seat. triangle_number &lt;- function(n) 0.5 * n * (n + 1) triangle_number(max(seats)) - triangle_number(min(seats) - 1) - sum(seats) ## [1] 539 "],["custom-customs.html", "Day 6 Custom Customs 6.1 Part 1 6.2 Part 2 6.3 Extra: solving part 1 &amp; 2 with set functions", " Day 6 Custom Customs This is my attempt to solve Day 6. load_file &lt;- function(file) { file %&gt;% read_file() %&gt;% # strip windows added carriage returns str_remove_all(&quot;\\r&quot;) %&gt;% # clear trailing whitespace str_trim() %&gt;% # split where we have two new lines str_split(&quot;\\n\\n&quot;) %&gt;% # take only the first results (the input is just one string) pluck(1) %&gt;% # split each result into individual lines str_split(&quot;\\n&quot;) } sample &lt;- load_file(&quot;samples/day_06_sample.txt&quot;) actual &lt;- load_file(&quot;inputs/day_06_input.txt&quot;) 6.1 Part 1 For part 1 I am going to first split each respondents response into the individual answers (str_extract_all()). This will return a list of character vectors, so I will use flatten_chr() to turn these into vectors containing all of the answers for each group as a character vector. Then I can simply take the unique() values and work out the length() of the resulting vector. I tie all of this together with the compose() function from {purrr}: this is similar to %&gt;%, except it chains the functions together before you evaluate them into a single chain. Like mathematical composition, compose() works with the “outer-most” function first, e.g. str_extract_all() runs before flatten_chr(), etc. part_1 &lt;- function(input) { input %&gt;% map_dbl(compose(length, unique, flatten_chr, str_extract_all), &quot;.&quot;) %&gt;% sum() } Now I can check that this function behaves as expected: part_1(sample) == 11 ## [1] TRUE And we can run on our actual data part_1(actual) ## [1] 6273 6.2 Part 2 For part 2 I am going to start as in part 1, split each respondents response into individual answers. But then I will use reduce() to go through pairs of responses at a time and only select the questions which were answered by both as “yes”. We can then simply take the length() of each groups responses. part_2 &lt;- function(input) { input %&gt;% map(str_extract_all, &quot;.&quot;) %&gt;% map(reduce, ~.y[.y %in% .x]) %&gt;% map_dbl(length) %&gt;% sum() } We can test to see if the function works as expected:: part_2(sample) == 6 ## [1] TRUE And run the function on the actual data. part_2(actual) ## [1] 3254 6.3 Extra: solving part 1 &amp; 2 with set functions We could solve part 1 and 2 with the same function. Part 1 is essentially just the union of set’s in each group, whereas part 2 is the intersection of set’s. So we can instead write a function that accepted a set function as an argument, like so: extra &lt;- function(input, fn) { input %&gt;% map(str_extract_all, &quot;.&quot;) %&gt;% map(reduce, fn) %&gt;% map_dbl(length) %&gt;% sum() } We can now check that this new function works as expected: extra(actual, union) == part_1(actual) ## [1] TRUE extra(actual, intersect) == part_2(actual) ## [1] TRUE "],["handy-haversacks.html", "Day 7 Handy Haversacks 7.1 Part 1 7.2 Part 2 7.3 Extra: alternative solution to part 2", " Day 7 Handy Haversacks This is my attempt to solve Day 7. sample &lt;- read_lines(&quot;samples/day_07_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_07_input.txt&quot;) 7.1 Part 1 I think today’s problem is naturally solved with using graph’s, so I’m going to use the {igraph} package. The easiest way to create a graph is to first create a data frame that contains the columns from and to that indicate which edges are in the graph. Any additional columns will be added as properties to the edge. convert_input_to_tibble &lt;- function(input) { input %&gt;% # we don&#39;t need to keep the word&#39;s &quot;bag&quot; or &quot;bags&quot;. In our data these words # always have a space before, and sometimes have a &quot;.&quot; at the end. We can # use the following regex to remove these words str_remove_all(&quot; bags?\\\\.?&quot;) %&gt;% # we can now split our data at the word &quot;contains&quot; unglue_data(&quot;{from} contain {contains}&quot;) %&gt;% # now we can split the contains column by comma&#39;s mutate(across(contains, str_split, &quot;, &quot;)) %&gt;% # and expand the nested &quot;contains&quot; column unnest_longer(contains) %&gt;% # handle edge case: if the string is no other need to insert a 0 at the start mutate(across(contains, ~if_else(.x == &quot;no other&quot;, &quot;0 no other&quot;, .x))) %&gt;% # now we can split the contains column into the &quot;n&quot; part and the &quot;to&quot; part separate(contains, c(&quot;n&quot;, &quot;to&quot;), &quot;(?&lt;=\\\\d) &quot;, convert = TRUE) %&gt;% # reorder the columns select(from, to, n) } sample_df &lt;- convert_input_to_tibble(sample) actual_df &lt;- convert_input_to_tibble(actual) sample_df ## # A tibble: 15 x 3 ## from to n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 light red bright white 1 ## 2 light red muted yellow 2 ## 3 dark orange bright white 3 ## 4 dark orange muted yellow 4 ## 5 bright white shiny gold 1 ## 6 muted yellow shiny gold 2 ## 7 muted yellow faded blue 9 ## 8 shiny gold dark olive 1 ## 9 shiny gold vibrant plum 2 ## 10 dark olive faded blue 3 ## 11 dark olive dotted black 4 ## 12 vibrant plum faded blue 5 ## 13 vibrant plum dotted black 6 ## 14 faded blue no other 0 ## 15 dotted black no other 0 We can create a graph using the graph_from_data_frame() function: sample_g &lt;- graph_from_data_frame(sample_df) sample_g ## IGRAPH 5e56380 DN-- 10 15 -- ## + attr: name (v/c), n (e/n) ## + edges from 5e56380 (vertex names): ## [1] light red -&gt;bright white light red -&gt;muted yellow ## [3] dark orange -&gt;bright white dark orange -&gt;muted yellow ## [5] bright white-&gt;shiny gold muted yellow-&gt;shiny gold ## [7] muted yellow-&gt;faded blue shiny gold -&gt;dark olive ## [9] shiny gold -&gt;vibrant plum dark olive -&gt;faded blue ## [11] dark olive -&gt;dotted black vibrant plum-&gt;faded blue ## [13] vibrant plum-&gt;dotted black faded blue -&gt;no other ## [15] dotted black-&gt;no other and visualise this graph using {igraph}: ggraph(sample_g, layout = &quot;igraph&quot;, algorithm = &quot;nicely&quot;) + geom_edge_link(aes(label = n), angle_calc = &quot;along&quot;, label_dodge = unit(2.5, &quot;mm&quot;), arrow = arrow(length = unit(3, &quot;mm&quot;)), end_cap = circle(10, &quot;mm&quot;)) + geom_node_label(aes(label = str_replace(name, &quot; &quot;, &quot;\\n&quot;))) Our challenge is to find all of the vertices that have a path in to “shiny gold”. The subcomponent() function can tell us all of the vertices in a graph which reach a given vertex. We can simply take the length of this subcomponent and subtract 1 (as the subcomponent includes “shiny gold”). length(subcomponent(sample_g, &quot;shiny gold&quot;, &quot;in&quot;)) - 1 == 4 ## [1] TRUE We now just need to solve for the actual data. actual_g &lt;- graph_from_data_frame(actual_df) length(subcomponent(actual_g, &quot;shiny gold&quot;, &quot;in&quot;)) - 1 ## [1] 278 7.2 Part 2 Part 2 sounds like a recursive function. We can first find the subgraph that includes all of the vertices from “shiny gold”. We can then convert this graph to an adjacency matrix and iterate through each vertex, recursively calling a function that sums how many bags this bag will contain. part_2 &lt;- function(input) { sg &lt;- induced_subgraph(input, subcomponent(input, &quot;shiny gold&quot;, &quot;out&quot;)) am &lt;- as_adjacency_matrix(sg, attr = &quot;n&quot;, sparse = FALSE) fn &lt;- function(am, v = &quot;shiny gold&quot;, n = 1) { a &lt;- am[v, ] * n a &lt;- a[a &gt; 0] # keep as separate step, otherwise can end up with just scalar # now, iterate over each item in a and recursively call this function sum(map_dbl(names(a), ~fn(am, .x, a[[.x]]))) + sum(a) } # call this function on the base case fn(am) } We can test that our function works against the sample case: part_2(sample_g) == 32 ## [1] TRUE A second sample is provided, so we can test against that also: c(&quot;shiny gold bags contain 2 dark red bags.&quot;, &quot;dark red bags contain 2 dark orange bags.&quot;, &quot;dark orange bags contain 2 dark yellow bags.&quot;, &quot;dark yellow bags contain 2 dark green bags.&quot;, &quot;dark green bags contain 2 dark blue bags.&quot;, &quot;dark blue bags contain 2 dark violet bags.&quot;, &quot;dark violet bags contain no other bags.&quot;) %&gt;% convert_input_to_tibble() %&gt;% graph_from_data_frame() %&gt;% part_2() == 126 ## [1] TRUE Now we can run against the actual data: part_2(actual_g) ## [1] 45157 7.3 Extra: alternative solution to part 2 We could also solve part 2 by iterating through each vertex and finding the incident edges and adjacent vertices. We multiply the edge weight (ie$n) by the current value of n, sum these values and add n back in to the total. This gives us the total number of bags, including the initial bag, so we need to subtract 1 from this answer. part_2_alt &lt;- function(g, v, n) { ie &lt;- incident_edges(g, v, &quot;out&quot;)[[1]] vn &lt;- ends(g, ie)[, 2] sum(map2_dbl(vn, ie$n * n, part_2_alt, g = g)) + n } We can now verify that this alternative function works as above. part_2_alt(sample_g, &quot;shiny gold&quot;, 1) - 1 == part_2(sample_g) ## [1] TRUE part_2_alt(actual_g, &quot;shiny gold&quot;, 1) - 1 == part_2(actual_g) ## [1] TRUE "],["handheld-halting.html", "Day 8 Handheld Halting 8.1 Part 1 8.2 Part 2 8.3 Extra: update the computer class", " Day 8 Handheld Halting This is my attempt to solve Day 8. sample &lt;- read_lines(&quot;samples/day_08_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_08_input.txt&quot;) 8.1 Part 1 Today I’m going to build an R6 class to handle the state of the computer. Computer &lt;- R6Class( &quot;Computer&quot;, public = list( initialize = function(instructions) { private$instructions &lt;- instructions %&gt;% unglue_data(&quot;{inst} {i}&quot;, convert = TRUE) %&gt;% mutate(c = 0) }, get_accumulator = function() { private$accumulator }, get_instructions_count = function() { sum(private$instructions$c) }, run_next = function() { next_instruction &lt;- private$next_instruction() private$run_instruction(next_instruction$inst, next_instruction$i) invisible(self) }, run_until_repeat = function() { repeat { next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, print = function(...) { i &lt;- private$instructions[private$ptr, ] cat(&quot;Accumulator: &quot;, private$accumulator, &quot;\\n&quot;) cat(&quot;Pointer: &quot;, private$ptr, &quot;\\n&quot;) cat(&quot;Instructions Ran:&quot;, self$get_instructions_count(), &quot;\\n&quot;) cat(&quot;Next Instruction:&quot;, i$inst, &quot; &quot;, sprintf(&quot;%+d&quot;, i$i), &quot; (&quot;, i$c, &quot;)\\n&quot;) } ), private = list( accumulator = 0, ptr = 1, instructions = list(), next_instruction = function() { private$instructions[private$ptr, ] }, run_instruction = function(inst, i) { private$instructions[private$ptr, &quot;c&quot;] &lt;- 1 + private$instructions[private$ptr, &quot;c&quot;] private$ptr &lt;- private[[inst]](i) }, # instruction functions: must return the next pointer value acc = function(i) { private$accumulator &lt;- private$accumulator + i private$ptr + 1 }, jmp = function(i) { private$ptr + i }, nop = function(i) { private$ptr + 1 } ) ) Now we can initialize our sample computer: sample_computer &lt;- Computer$new(sample) sample_computer ## Accumulator: 0 ## Pointer: 1 ## Instructions Ran: 0 ## Next Instruction: nop +0 ( 0 ) And we can run the next instruction: sample_computer$run_next() sample_computer ## Accumulator: 0 ## Pointer: 2 ## Instructions Ran: 1 ## Next Instruction: acc +1 ( 0 ) We can run the computer until we repeat an instruction: sample_computer$run_until_repeat() sample_computer ## Accumulator: 5 ## Pointer: 2 ## Instructions Ran: 7 ## Next Instruction: acc +1 ( 1 ) According to the days text, the accumulator should be 5, and we should have run 7 instructions, which we can see is the output from the sample_computer. Now we can run the actual data: actual_computer &lt;- Computer$new(actual) actual_computer$run_until_repeat() actual_computer ## Accumulator: 1816 ## Pointer: 580 ## Instructions Ran: 211 ## Next Instruction: jmp -101 ( 1 ) 8.2 Part 2 We need to modify our computer slightly. First, we need to introduce a way to see if our computer has halted, which will be when the pointer has exceeded the length of the instructions. Second, we need to be able to flip nop to jmp and jmp to nop. There may be a smarter way to figure out which to flip, but I’m just going to iterate through the initial input and flip one at a time. If the computer halt’s then we have found our solution. Rather than recreating the Computer class, we can use Computer$set() to add a halted method and a run_until_halted_or_repeat method. Computer$set(&quot;public&quot;, &quot;is_halted&quot;, function() { private$ptr &gt; nrow(private$instructions) }) Computer$set(&quot;public&quot;, &quot;run_until_halted_or_repeat&quot;, function() { repeat { if (self$is_halted()) { break() } next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }) Now we need to build a function to take our list of instructions and flip all of the nop/jmp instructions: flip_instructions &lt;- function(input) { input %&gt;% str_detect(&quot;^(?!acc)&quot;) %&gt;% which() %&gt;% map(function(.x) { ix &lt;- input[[.x]] str_sub(input[[.x]], 1, 3) &lt;- if(str_sub(input[[.x]], 1, 3) == &quot;nop&quot;) { &quot;jmp&quot; } else { &quot;nop&quot; } input }) } Our sample flipped looks like this: flip_instructions(sample) ## [[1]] ## [1] &quot;jmp +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[2]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;nop +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[3]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;nop -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## [[4]] ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;nop -4&quot; &quot;acc +6&quot; We have 4 set’s of instructions to test. This isn’t the most efficient way of solving this… we could flip each of the instructions in turn, and run the computer on that. This would allow us to exit early. But I don’t think that this will cause us much issues as our actual input isn’t huge (length(actual) instructions). Now we just need to build a function to iterate over the flipped instructions and run until we find a solution, and return the results of that computer. part_2 &lt;- function(input) { for (i in flip_instructions(input)) { computer &lt;- Computer$new(i) computer$run_until_halted_or_repeat() if (computer$is_halted()) { return(list(input = input, computer = computer)) } } stop(&quot;No solution found!&quot;) } part_2(sample) ## $input ## [1] &quot;nop +0&quot; &quot;acc +1&quot; &quot;jmp +4&quot; &quot;acc +3&quot; &quot;jmp -3&quot; &quot;acc -99&quot; &quot;acc +1&quot; ## [8] &quot;jmp -4&quot; &quot;acc +6&quot; ## ## $computer ## Accumulator: 8 ## Pointer: 10 ## Instructions Ran: 6 ## Next Instruction: NA NA ( NA ) This is the result that we are expecting, so we can run this for the actual data: part_2(actual)$computer ## Accumulator: 1149 ## Pointer: 627 ## Instructions Ran: 123 ## Next Instruction: NA NA ( NA ) 8.3 Extra: update the computer class Redefining the entire class to include the added methods in part 2, and to redefine the print method Computer &lt;- R6Class( &quot;Computer&quot;, public = list( initialize = function(instructions) { private$instructions &lt;- instructions %&gt;% unglue_data(&quot;{inst} {i}&quot;, convert = TRUE) %&gt;% mutate(c = 0) }, get_accumulator = function() { private$accumulator }, get_instructions_count = function() { sum(private$instructions$c) }, run_next = function() { next_instruction &lt;- private$next_instruction() private$run_instruction(next_instruction$inst, next_instruction$i) invisible(self) }, run_until_repeat = function() { repeat { next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, is_halted = function() { private$ptr &gt; nrow(private$instructions) }, run_until_halted_or_repeat = function() { repeat { if (self$is_halted()) { break() } next_instruction &lt;- private$next_instruction() if (next_instruction$c &gt; 0) { break() } private$run_instruction(next_instruction$inst, next_instruction$i) } invisible(self) }, print = function(...) { cat(&quot;Accumulator: &quot;, private$accumulator, &quot;\\n&quot;) cat(&quot;Pointer: &quot;, private$ptr, &quot;\\n&quot;) cat(&quot;Instructions Ran:&quot;, self$get_instructions_count(), &quot;\\n&quot;) cat(&quot;Next Instruction: &quot;) if (self$is_halted()) { cat(&quot;HALTED\\n&quot;) } else { i &lt;- private$instructions[private$ptr, ] cat(i$inst, &quot; &quot;, sprintf(&quot;%+d&quot;, i$i), &quot; (&quot;, i$c, &quot;)\\n&quot;) } } ), private = list( accumulator = 0, ptr = 1, instructions = list(), next_instruction = function() { private$instructions[private$ptr, ] }, run_instruction = function(inst, i) { private$instructions[private$ptr, &quot;c&quot;] &lt;- 1 + private$instructions[private$ptr, &quot;c&quot;] private$ptr &lt;- private[[inst]](i) }, # instruction functions: must return the next pointer value acc = function(i) { private$accumulator &lt;- private$accumulator + i private$ptr + 1 }, jmp = function(i) { private$ptr + i }, nop = function(i) { private$ptr + 1 } ) ) "],["encoding-error.html", "Day 9 Encoding Error 9.1 Part 1 9.2 Part 2", " Day 9 Encoding Error This is my attempt to solve Day 9. sample &lt;- read_lines(&quot;samples/day_09_sample.txt&quot;) %&gt;% as.numeric() actual &lt;- read_lines(&quot;inputs/day_09_input.txt&quot;) %&gt;% as.numeric() 9.1 Part 1 We can solve part 1 by creating a function that slides a window (r) across the input and checks to see if the value of the element i just after the end of the current window, minus all of the values in that window, is in the window. part_1 &lt;- function(input, n) { i &lt;- n + 1 r &lt;- 1:n while (any((input[[i]] - input[r]) %in% input[r])) { r &lt;- r + 1 i &lt;- i + 1 } input[[i]] } We can now check our function gives us the right answer for the sample: ps1 &lt;- part_1(sample, 5) ps1 == 127 ## [1] TRUE This gives us the correct answer, so we can now run on the actual input: pa1 &lt;- part_1(actual, 25) pa1 ## [1] 57195069 9.2 Part 2 The naive approach here is to start to use nested for loops to sum the values. There is probably a smarter way of solving this, but it’s the approach I will use. Instead of using the sum, min and max functions available in R I am going to keep track of the values: this should give us a slight performance boost by not having to iterate through all of the values each time. part_2 &lt;- function(input, t) { s &lt;- which(input == t) # we need to loop until just before the index of the target in the input # as we are using nested loops it should be s - 2 here for (i in 1:(s - 2)) { sv &lt;- input[[i]] # keep track of the sum minv &lt;- sv # and the min value maxv &lt;- sv # and the max value # now we need to loop from the next value (i + 1) to just before the target for (j in (i + 1):(s - 1)) { # update the sum sv &lt;- sv + input[[j]] # if we exceed the target then break out the loop and move to the next i if (sv &gt; t) next() # update the min and max values if (input[[j]] &lt; minv) minv &lt;- input[[j]] if (input[[j]] &gt; maxv) maxv &lt;- input[[j]] # if our sum is equal to the target, then return the sum of the min and # max value if (sv == t) return (minv + maxv) } } } We can test on the sample: part_2(sample, ps1) == 62 ## [1] TRUE And run on the actual input: part_2(actual, pa1) ## [1] 7409241 "],["adapter-array.html", "Day 10 Adapter Array 10.1 Part 1 10.2 Part 2", " Day 10 Adapter Array This is my attempt to solve Day 10. sample &lt;- read_lines(&quot;samples/day_10_sample.txt&quot;) %&gt;% as.numeric() actual &lt;- read_lines(&quot;inputs/day_10_input.txt&quot;) %&gt;% as.numeric() 10.1 Part 1 We can solve part 1 pretty easily using base R functions. First, sort the input. We can then use diff() to calculate the differences between each successive pairs of values, then we can use table() to count how many of each value appears. We can then multiply the values using the prod() (product) function. We just need to remember to add “0” to our input, and the value that is 3 greater than the maximum value in the input. part_1 &lt;- function(input) { c(0, input, max(input + 3)) %&gt;% sort() %&gt;% diff() %&gt;% table() %&gt;% prod() } We can now test our function on the sample: part_1(sample) == 22 * 10 ## [1] TRUE And we can run the function with the actual data: part_1(actual) ## [1] 2475 10.2 Part 2 Part 2 can be solved with Dynamic Programming. We will start at the beginning of the sorted input, and iterate over each item in turn. At each item we find which other items can be reached and increase their counts by the current items count. Once we reach the end of the list we have the answer. part_2 &lt;- function(input) { # ensure input is sorted input &lt;- sort(input) # create a list of values for our counts, initialise to 0 t &lt;- rep(0, length(input)) # set all of the items that can be reached from &quot;0&quot; to 1 t[input &lt;= 3] &lt;- 1 # iterate over the input for (i in seq_along(input)) { # get the current item in the input x &lt;- input[[i]] # get the indexes of the items that can be reached from the current item r &lt;- input &gt; x &amp; input &lt;= x + 3 # update the items that can be reached t[r] &lt;- t[[i]] + t[r] } # return just the final value tail(t, 1) } We can test our part 2 function on the sample data: part_2(sample) == 19208 ## [1] TRUE We know that the actual solution will be a giant number, so make sure R doesn’t format the number in scientific notation by setting the scipen option. options(scipen = 999) part_2(actual) ## [1] 442136281481216 "],["seating-system.html", "Day 11 Seating System 11.1 Part 1 11.2 Part 2 11.3 Solving faster", " Day 11 Seating System This is my attempt to solve Day 11. sample &lt;- read_lines(&quot;samples/day_11_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_11_input.txt&quot;) 11.1 Part 1 We are given that in our input: . is the floor L is an empty seat # is an occupied seat It will make our life simpler to add a border of empty seats round our inputs, and convert the input to a matrix of individual characters process_input &lt;- function(input) { dl &lt;- paste(rep(&quot;.&quot;, str_length(input[[1]])), collapse = &quot;&quot;) m &lt;- paste0(&quot;.&quot;, c(dl, input, dl), &quot;.&quot;) %&gt;% str_extract_all(&quot;.&quot;, simplify = TRUE) # give this matrix an s3 class of &quot;day11&quot; structure(m, class = c(&quot;day11&quot;, class(m))) } # implement a print method for our day11 class print.day11 &lt;- function(x, ...) { cat(paste(apply(x, 1, paste, collapse = &quot;&quot;), collapse = &quot;\\n&quot;), &quot;\\n&quot;) } psample &lt;- process_input(sample) pactual &lt;- process_input(actual) We can now have a quick look at our sample input: psample ## ............ ## .L.LL.LL.LL. ## .LLLLLLL.LL. ## .L.L.L..L... ## .LLLL.LL.LL. ## .L.LL.LL.LL. ## .L.LLLLL.LL. ## ...L.L...... ## .LLLLLLLLLL. ## .L.LLLLLL.L. ## .L.LLLLL.LL. ## ............ Now we can build a function to run n iteration’s: p1_run_iterations &lt;- function(input, n = 1, count = 0) { # this is a recursive function, when n is less than 1 stop iterating and # return whatever input is given if (n &lt; 1) return (list(input = input, count = count)) # take a copy of the current state - we will modify this copied state and # return it for the next iteration next_state &lt;- input for (r in 2:(nrow(input) - 1)) { for (c in 2:(ncol(input) - 1)) { # skip this cell if it&#39;s a . if (input[r, c] == &quot;.&quot;) next() # get adjacent seats adjacent &lt;- c(input[r - 1, c - 1], input[r - 1, c ], input[r - 1, c + 1], input[r , c - 1], input[r , c + 1], input[r + 1, c - 1], input[r + 1, c ], input[r + 1, c + 1]) # count how many are occupied occupied &lt;- sum(ifelse(adjacent == &quot;#&quot;, 1, 0)) if (input[r, c] == &quot;L&quot;) { if (occupied == 0) { next_state[r, c] &lt;- &quot;#&quot; } } else { # it can only be &quot;#&quot; now if (occupied &gt;= 4) { next_state[r, c] &lt;- &quot;L&quot; } } } } if (all(next_state == input)) { return (list(input = input, count = count)) } # run the next itertion, decreasing n by 1 p1_run_iterations(next_state, n - 1, count + 1) } We can now test our function runs as expected on the sample. p1_run_iterations(psample) ## $input ## ............ ## .#.##.##.##. ## .#######.##. ## .#.#.#..#... ## .####.##.##. ## .#.##.##.##. ## .#.#####.##. ## ...#.#...... ## .##########. ## .#.######.#. ## .#.#####.##. ## ............ ## ## $count ## [1] 1 p1_run_iterations(psample, 2) ## $input ## ............ ## .#.LL.L#.##. ## .#LLLLLL.L#. ## .L.L.L..L... ## .#LLL.LL.L#. ## .#.LL.LL.LL. ## .#.LLLL#.##. ## ...L.L...... ## .#LLLLLLLL#. ## .#.LLLLLL.L. ## .#.#LLLL.##. ## ............ ## ## $count ## [1] 2 These match the examples, we just need to check it terminates correctly: p1s &lt;- p1_run_iterations(psample, Inf) p1s$count == 5 ## [1] TRUE We just need a way to count the seats occupied now: count_seats &lt;- function(x) { sum(x$input == &quot;#&quot;) } Which we can run on the variable p1s from above: count_seats(p1s) == 37 ## [1] TRUE While this does run, it’s not particular fast on the actual data. We come back to part 1 later. # disabled chunk pactual %&gt;% p1_run_iterations(Inf) %&gt;% count_seats() 11.2 Part 2 We now need to modify our run iterations function. I am going to embed a function that will search for the first seat, and update the tolerance from 4 to 5. In order to speed up computation we first calculate the “first seat” found from any position. In order to remember these seats we switch from a recursive function to use a loop. Otherwise, the function remains the same as in part 1. p2_run_iterations &lt;- function(input, n) { # create a function to find the first seat that can be seen from r, c in the # direction rd, cd. rd / cd should be 1, -1 or 0, but both should not be 0 find_first_seat &lt;- function(r, c, rd, cd) { rr &lt;- r cc &lt;- c if (input[rr, cc] == &quot;.&quot;) { # return a cell that will be a &quot;.&quot; return (c(1, 1)) } repeat { rr &lt;- rr + rd cc &lt;- cc + cd if (rr &lt; 1 | rr &gt; nrow(input) | cc &lt; 1 | cc &gt; ncol(input) ) { # return a cell that will be a &quot;.&quot; return (c(1, 1)) } else if (input[rr, cc] != &quot;.&quot;) { # return the indexes return (c(rr, cc)) } } } first_seats &lt;- map(2:(nrow(input) - 1), function(r) { map(2:(ncol(input) - 1), function(c) { list( rd = c(-1, -1, -1, 0, 0, 1, 1, 1), cd = c(-1, 0, 1, -1, 1, -1, 0, 1) ) %&gt;% pmap(find_first_seat, r = r, c = c) %&gt;% discard(compose(any, is.na)) }) }) count &lt;- 0 state &lt;- input while (count &lt; n) { # take a copy of the current state - we will modify this copied state and # return it for the next iteration next_state &lt;- state for (r in 2:(nrow(state) - 1)) { for (c in 2:(ncol(state) - 1)) { # skip this cell if it&#39;s a . if (state[r, c] == &quot;.&quot;) next() # our first seats only iterated over the &quot;inside&quot; range, so we need to # subtract 1 from the r and c index adjacent &lt;- map_chr(first_seats[[r - 1]][[c - 1]], ~state[.x[[1]], .x[[2]]]) # count how many are occupied occupied &lt;- sum(adjacent == &quot;#&quot;) if (state[r, c] == &quot;L&quot;) { if (occupied == 0) { next_state[r, c] &lt;- &quot;#&quot; } } else { # it can only be &quot;#&quot; now if (occupied &gt;= 5) { next_state[r, c] &lt;- &quot;L&quot; } } } } if (all(next_state == state)) { break() } state &lt;- next_state count &lt;- count + 1 } list(input = state, count = count) } We can test our function works as expected after 1 iteration: psample %&gt;% p2_run_iterations(1) ## $input ## ............ ## .#.##.##.##. ## .#######.##. ## .#.#.#..#... ## .####.##.##. ## .#.##.##.##. ## .#.#####.##. ## ...#.#...... ## .##########. ## .#.######.#. ## .#.#####.##. ## ............ ## ## $count ## [1] 1 And after 2 iterations: psample %&gt;% p2_run_iterations(2) ## $input ## ............ ## .#.LL.LL.L#. ## .#LLLLLL.LL. ## .L.L.L..L... ## .LLLL.LL.LL. ## .L.LL.LL.LL. ## .L.LLLLL.LL. ## ...L.L...... ## .LLLLLLLLL#. ## .#.LLLLLL.L. ## .#.LLLLL.L#. ## ............ ## ## $count ## [1] 2 We can use the count_seats() function again to test our new function works: psample %&gt;% p2_run_iterations(Inf) %&gt;% count_seats() == 26 ## [1] TRUE Again, this function runs very slowly on the actual data. # disabled chunk pactual %&gt;% p2_run_iterations(Inf) %&gt;% count_seats() 11.3 Solving faster R is much better at vectorised operations, so if we could reduce the steps to summing matrices our code should run much faster. First, we are to treat our input as a matrix that contains either 0 for an unoccupied seat, 1 for an occupied seat, and NA for the floor. We then create functions for part 1 and for part 2 which returns 8 set’s of indices for the directions that we are to look in for seats. These index sets will be used to return a matrix the same size as the inner part of our matrix (we ignore the border). Part 1’s function is pretty simple, we simply shift the matrix one up, one to the left, then just one up, then one up and one to the right, etc. This function is pretty slow as we have to allocate quite a lot of memory. part_one &lt;- function(input) { nr &lt;- nrow(input) nc &lt;- ncol(input) cross2(1:3, 1:3) %&gt;% discard(~ .x[[1]] == 2 &amp;&amp; .x[[2]] == 2) %&gt;% map(function(.x) { cross_df( list( row = .x[[1]]:(nr - 3 + .x[[1]]), col = .x[[2]]:(nc - 3 + .x[[2]]) ) ) %&gt;% as.matrix() }) } Part 2 is slightly more complex as we need to find the seat according to the more complex rules. part_two &lt;- function(input) { nr &lt;- nrow(input) nc &lt;- ncol(input) find_in_direction &lt;- function(r, c, rd, cd) { ri &lt;- r ci &lt;- c repeat { ri &lt;- ri + rd ci &lt;- ci + cd # we have reached the boundary, exit if (ri &lt; 1 | ri &gt; nr | ci &lt; 1 | ci &gt; nc) { return (list(row = ri - rd, col = ci - cd)) } # we have found a seat, return if (!is.na(input[ri, ci])) { return (list(row = ri, col = ci)) } } } # get the indices of each cell in the inner part of the input matrix ixs &lt;- cross_df(list(r = 2:(nr - 1), c = 2:(nc - 1))) # now find the values in each direction list( pmap_dfr(ixs, find_in_direction, -1, -1), pmap_dfr(ixs, find_in_direction, -1, 0), pmap_dfr(ixs, find_in_direction, -1, 1), pmap_dfr(ixs, find_in_direction, 0, -1), pmap_dfr(ixs, find_in_direction, 0, 1), pmap_dfr(ixs, find_in_direction, 1, -1), pmap_dfr(ixs, find_in_direction, 1, 0), pmap_dfr(ixs, find_in_direction, 1, 1) ) %&gt;% map(as.matrix) } We now create a solving function, which takes the data as the first argument, either part_one() or part_two() as the second argument, and the tolerance (4 for part 1, 5 for part 2). solve &lt;- function(x, add_mat_fn, tolerance) { input &lt;- ifelse(unclass(x) == &quot;L&quot;, 0, NA) nr &lt;- nrow(input) nc &lt;- ncol(input) add_mat_ix &lt;- add_mat_fn(input) repeat { # use this to check later if our matrix has changed t &lt;- input # use our matrix indices, find the values for the 8 shifted matrices, then # add the 8 matrices together to give us one matrix that tells us how many # adjacent seats are occupied add_mat &lt;- add_mat_ix %&gt;% map(~input[.x] %&gt;% replace_na(0) %&gt;% matrix(nrow = nr - 2, ncol = nc - 2)) %&gt;% reduce(`+`) # find the unoccupied seats in the input y &lt;- which(input == 0, arr.ind = TRUE) # and the occupied seats z &lt;- which(input == 1, arr.ind = TRUE) # update the unoccupied seats input[y] &lt;- 1 * (add_mat[y - 1] == 0) # update the occupied seats input[z] &lt;- 1 * (add_mat[z - 1] &lt; tolerance) # check to see if our matrix has changed if (all(t == input, na.rm = TRUE)) break() } # now just return the number of occupied seats sum(input, na.rm = TRUE) } We can now run our new function’s and see if they give us the same results as above: solve(psample, part_one, 4) ## [1] 37 solve(pactual, part_one, 4) ## [1] 2483 solve(psample, part_two, 5) ## [1] 26 solve(pactual, part_two, 5) ## [1] 2285 "],["rain-risk.html", "Day 12 Rain Risk 12.1 Part 1 12.2 Part 2", " Day 12 Rain Risk This is my attempt to solve Day 12. sample &lt;- read_lines(&quot;samples/day_12_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_12_input.txt&quot;) 12.1 Part 1 Today’s task could be a tedious series of if else statements. Instead I will use Object-Orientated Programming and the s3 class system. I will strip the initial input to just be the number, but I will give each of the inputs a class of “N”, “E”, “W”, “S”, “F”, “R”, or “L”. split_instructions &lt;- function(input) { transpose( list( d = str_sub(input, 1, 1), n = as.integer(str_sub(input, 2)) ) ) %&gt;% map(function(.x) { structure(.x$n, class = .x$d) }) } isample &lt;- split_instructions(sample) iactual &lt;- split_instructions(actual) isample ## [[1]] ## [1] 10 ## attr(,&quot;class&quot;) ## [1] &quot;F&quot; ## ## [[2]] ## [1] 3 ## attr(,&quot;class&quot;) ## [1] &quot;N&quot; ## ## [[3]] ## [1] 7 ## attr(,&quot;class&quot;) ## [1] &quot;F&quot; ## ## [[4]] ## [1] 90 ## attr(,&quot;class&quot;) ## [1] &quot;R&quot; ## ## [[5]] ## [1] 11 ## attr(,&quot;class&quot;) ## [1] &quot;F&quot; First, let’s define the initial state: initial_state &lt;- list(direction = &quot;E&quot;, position = c(0, 0)) We now need to create a function called that will run an instruction: I will call this function inst. It will take as argument the object itself (n), this will contain the number from the input. It will also take the current state. inst &lt;- function(n, state) { UseMethod(&quot;inst&quot;) } Now we need to implement a method for each of the classes. Let’s start with the N/E/S/W classes. These methods are pretty simple, we just need to add on n to the current position. # create a helper function that the other functions use inst_NESW_helper &lt;- function(state, p) { state$position &lt;- state$position + p state } inst.N &lt;- function(n, state) inst_NESW_helper(state, c( n, 0)) inst.E &lt;- function(n, state) inst_NESW_helper(state, c( 0, n)) inst.S &lt;- function(n, state) inst_NESW_helper(state, c(-n, 0)) inst.W &lt;- function(n, state) inst_NESW_helper(state, c( 0, -n)) The L/R functions are slightly more tricky, but, looking at the actual data there are only 3 different angles that are turned: actual %&gt;% str_subset(&quot;L|R&quot;) %&gt;% str_remove(&quot;L|R&quot;) %&gt;% unique() ## [1] &quot;90&quot; &quot;180&quot; &quot;270&quot; We can create our function now. This time, we our helper function will just rotate the direction that we are facing. inst_LR_helper &lt;- function(state, r) { directions &lt;- c(&quot;N&quot;, &quot;E&quot;, &quot;S&quot;, &quot;W&quot;) current &lt;- which(state$direction == directions) - 1 next_direction &lt;- (current + r / 90) %% 4 state$direction = directions[[next_direction + 1]] state } # L turns anti-clockwise, so we can turn it into a clockwise rotation inst.L &lt;- function(n, state) inst_LR_helper(state, 360 - n) inst.R &lt;- function(n, state) inst_LR_helper(state, n) Finally we can create our function for moving forward. In this case we will take the value from n, but update the class to be that of the current direction from state. inst.F &lt;- function(n, state) { nn &lt;- structure(n, class = state$direction) inst(nn, state) } Now we have all the parts we can build our function to solve part 1. We start with an initial state, and keep calling a function on each successive value in the input with the current state. To do this we can use the reduce function. solve &lt;- function(input, state = initial_state) { final_state &lt;- reduce( input, .init = initial_state, function (state, instruction) { inst(instruction, state) } ) sum(abs(final_state$position)) } Checking the sample data: solve(isample) == 25 ## [1] TRUE We can now run with the actual data: solve(iactual) ## [1] 1032 12.2 Part 2 We can now update our instruction functions, our solver should still work. First we need to update our initial state. initial_state &lt;- list(waypoint = c(1, 10), position = c(0, 0)) We can cheat a bit on the N/E/S/W functions: we can just change the update position helper function to instead update the waypoint. inst_NESW_helper &lt;- function(state, p) { state$waypoint &lt;- state$waypoint + p state } Likewise, we just need to update the L/R helper function. We can use matrix multiplication to rotate our waypoint. inst_LR_helper &lt;- function(state, r) { # r is either 90, 180, 270, and it a clockwise rotation rot_mat &lt;- matrix( if (r == 90) { c(0, 1, -1, 0) } else if (r == 180) { c(-1, 0, 0, -1) } else { c(0, -1, 1, 0) }, nrow = 2 ) state$waypoint &lt;- (rot_mat %*% state$waypoint)[,1] state } We now just need to update the F function. inst.F &lt;- function(n, state) { w &lt;- state$waypoint s &lt;- state$position state$position &lt;- w * n + s state } We should now be in a position to run our solve function again. Checking the sample: solve(isample) == 286 ## [1] TRUE We can now run with the actual data: solve(iactual) ## [1] 156735 "],["shuttle-search.html", "Day 13 Shuttle Search 13.1 Part 1 13.2 Part 2", " Day 13 Shuttle Search This is my attempt to solve Day 13. sample &lt;- read_lines(&quot;samples/day_13_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_13_input.txt&quot;) 13.1 Part 1 We can solve part 1 by finding the first time each of the buses arrives after we arrive, then finding which bus has the minimum time. part_1 &lt;- function(input) { earliest_time &lt;- as.integer(input[[1]]) buses &lt;- input[[2]] %&gt;% str_split(&quot;,&quot;) %&gt;% pluck(1) %&gt;% str_subset(&quot;\\\\d&quot;) %&gt;% as.integer() first_available &lt;- ceiling(earliest_time / buses) * buses which_bus &lt;- which.min(first_available) (first_available[[which_bus]] - earliest_time) * buses[[which_bus]] } We can check that this function works on the sample data: part_1(sample) == 295 ## [1] TRUE And we can run with the actual data part_1(actual) ## [1] 3269 13.2 Part 2 Part 2 could be solved with the Chinese Remainder Theorem, but we could solve it more simply by iterating over the input items and keeping track of the current time and the current “jump” size. The jump size is equal to the cumulative product of the busses. part_2 &lt;- function(input) { # take the 2nd row of the input, convert x&#39;s to 0&#39;s x &lt;- input[[2]] %&gt;% str_replace_all(&quot;x&quot;, &quot;0&quot;) %&gt;% str_split(&quot;,&quot;) %&gt;% pluck(1) %&gt;% as.numeric() # get the sequence of values that are non zero, index from 0 y &lt;- seq_along(x)[x != 0] - 1 # get rid of the 0&#39;s (x&#39;s) x &lt;- x[x != 0] # start with a jump equal to the first value in the input j &lt;- x[1] # start at time 0 t &lt;- 0 # iterate over the input, skipping the first item for (i in 2:length(x)) { # increase our time by the size of the jump while the time + step size is # not a divisor of the current input item while ((t + y[[i]]) %% x[[i]]) { t &lt;- t + j } # increase the size of our jump by the current input item (bus) j &lt;- j * x[[i]] } # return the time t } We can run this function on the sample data. part_2(sample) == 1068781 ## [1] TRUE And we can run on the actual data. We need to make sure that we alter the “scientific notation penalty” option to view the answer as an integer. options(scipen = 999) part_2(actual) ## [1] 672754131923874 "],["docking-data.html", "Day 14 Docking Data 14.1 Part 1 14.2 Part 2", " Day 14 Docking Data This is my attempt to solve Day 14. sample &lt;- read_lines(&quot;samples/day_14_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_14_input.txt&quot;) 14.1 Part 1 Part 1 requires us to apply a “bitmask” to a number. The function packBits() can convert a vector of raw values back to an integer, but there are 2 issues. First, integers in R are signed 32-bit values, and our mask is 36-bits long. We need to handle the sign bit separately, otherwise we may end up with negative numbers. Secondly, packBits() is big endian, but the mask is little endian. So we need to reverse the values in the mask. We can solve today’s problem by taking two copies of the mask. mask0 will be where we apply the replace 0 logic. We can achieve this with a bitwise and, and a mask of all 1’s except where the mask is a 0. mask1 will be where we apply the replace 1 logic. We can achieve this with a bitwise or, and a mask of all 0’s except where the mask is a 1. part_1_apply_mask &lt;- function(value, mask) { mask &lt;- str_extract_all(mask, &quot;.&quot;)[[1]] %&gt;% rev() mask0 &lt;- str_replace(mask, &quot;X&quot;, &quot;1&quot;) %&gt;% as.raw() mask1 &lt;- str_replace(mask, &quot;X&quot;, &quot;0&quot;) %&gt;% as.raw() # ignore the most significant bit... assume all our numbers are positive... mask0_lsb &lt;- packBits(c(mask0[1:31], raw(1)), &quot;integer&quot;) mask1_lsb &lt;- packBits(c(mask1[1:31], raw(1)), &quot;integer&quot;) mask1_msb &lt;- packBits(c(mask1[32:36], raw(27)), &quot;integer&quot;) v &lt;- value %&gt;% bitwAnd(mask0_lsb) %&gt;% bitwOr(mask1_lsb) as.numeric(v) + as.numeric(mask1_msb) * (2 ** 31) } We can now solve part 1 by building a data frame that has a column for the mask along with the value. Note that if a memory location is updated twice we only keep the last value, so we can group by the memory locations and just keep the last value. part_1 &lt;- function(input) { input %&gt;% unglue_data(&quot;{instruction} = {value}&quot;) %&gt;% mutate(mask = ifelse(instruction == &quot;mask&quot;, value, NA)) %&gt;% fill(mask) %&gt;% filter(instruction != &quot;mask&quot;) %&gt;% mutate(across(instruction, str_extract, &quot;\\\\d+&quot;), across(c(instruction, value), as.integer)) %&gt;% group_by(instruction) %&gt;% summarise(across(everything(), last), .groups = &quot;drop&quot;) %&gt;% mutate(new_val = map2_dbl(value, mask, part_1_apply_mask)) %&gt;% pull(new_val) %&gt;% sum() } We can now test our function with the sample data: part_1(sample) == 165 ## [1] TRUE And we can run with the actual data: part_1(actual) ## [1] 15514035145260 14.2 Part 2 In part 2 we have a more complex scenario. We create a new “apply mask” function that will apply these rules. This function will take the current memory, apply the rules for the current row of data, then return the memory. This can be used in within reduce() to iterate over the data and update the memory. part_2_apply_mask &lt;- function(memory, mem_loc, value, mask) { m &lt;- str_extract_all(mask, &quot;.&quot;)[[1]] # convert mem_loc to a binary number mem_loc_b &lt;- c(raw(4), rev(intToBits(mem_loc))) all_mem_locs &lt;- list(mem_loc_b) for (i in 1:36) { if (m[[i]] == &quot;1&quot;) { for (j in seq_along(all_mem_locs)) { all_mem_locs[[j]][[i]] &lt;- as.raw(1) } } else if (m[[i]] == &quot;X&quot;) { a &lt;- all_mem_locs b &lt;- all_mem_locs for (j in seq_along(all_mem_locs)) { a[[j]][[i]] &lt;- as.raw(0) b[[j]][[i]] &lt;- as.raw(1) } all_mem_locs &lt;- c(a, b) } } for (ml in all_mem_locs) { mls &lt;- paste(ml, collapse = &quot;&quot;) memory[[mls]] &lt;- value } memory } Part 2 provides a new sample sample_2 &lt;- c(&quot;mask = 000000000000000000000000000000X1001X&quot;, &quot;mem[42] = 100&quot;, &quot;mask = 00000000000000000000000000000000X0XX&quot;, &quot;mem[26] = 1&quot;) We build a function now for solving part 2. We start by reusing the data processing step from part 1. We can then use a little helper function to run the part_2_apply_mask() function, and put it all together with a reduce() over the data. part_2 &lt;- function(input) { data &lt;- input %&gt;% unglue_data(&quot;{instruction} = {value}&quot;) %&gt;% mutate(mask = ifelse(instruction == &quot;mask&quot;, value, NA)) %&gt;% fill(mask) %&gt;% filter(instruction != &quot;mask&quot;) %&gt;% mutate(across(instruction, str_extract, &quot;\\\\d+&quot;), across(c(instruction, value), as.integer)) %&gt;% rename(mem_loc = instruction) part_2_fn &lt;- function(memory, data_row) { with(data_row, { part_2_apply_mask(memory, mem_loc, value, mask) }) } data %&gt;% transpose() %&gt;% reduce(part_2_fn, .init = list()) %&gt;% flatten_dbl() %&gt;% sum() } We can now run our function on the new sample data part_2(sample_2) == 208 ## [1] TRUE part_2(actual) ## [1] 3926790061594 "],["rambunctious-recitation.html", "Day 15 Rambunctious Recitation 15.1 Part 1 15.2 Part 2", " Day 15 Rambunctious Recitation This is my attempt to solve Day 15. sample &lt;- c(0,3,6) actual &lt;- c(12,1,16,3,11,0) 15.1 Part 1 Ideally we would use a data type like a dictionary in Python for today’s problem… but there isn’t really a good option in R. Instead I will just assign a vector that will be long enough for the solution. I’m going to make an assumption that the largest number we will see will be less than the number of turns. solve &lt;- function(input, turns) { turn &lt;- numeric(turns) # first iterate over the input for (i in seq_along(input)) { p &lt;- input[[i]] # R is 1 indexed, make it 0 turn[[p + 1]] &lt;- i } # now continue for the rest of the turns for (i in (length(input) + 1):turns) { # find out which value was spoke t &lt;- turn[[p + 1]] # update the value of the turn turn[[p + 1]] &lt;- i - 1 # find which word is to be spoke p &lt;- ifelse(t == 0, 0, i - t - 1) } p } We can now test that our function works against the sample data: solve(sample, 4) == &quot;0&quot; ## [1] TRUE solve(sample, 5) == &quot;3&quot; ## [1] TRUE solve(sample, 6) == &quot;3&quot; ## [1] TRUE solve(sample, 7) == &quot;1&quot; ## [1] TRUE solve(sample, 8) == &quot;0&quot; ## [1] TRUE solve(sample, 9) == &quot;4&quot; ## [1] TRUE solve(sample, 10) == &quot;0&quot; ## [1] TRUE solve(sample, 2020) == 436 ## [1] TRUE We can now run our function on the actual data: solve(actual, 2020) ## [1] 1696 15.2 Part 2 We don’t need to change anything for part 2, other than the number of turns. solve(actual, 30000000) ## [1] 37385 "],["ticket-translation.html", "Day 16 Ticket Translation 16.1 Part 1 16.2 Part 2", " Day 16 Ticket Translation This is my attempt to solve Day 16. # process the files process_file &lt;- function(file) { file %&gt;% # strip windows new line carriage return charaters str_replace_all(&quot;\\r&quot;, &quot;&quot;) %&gt;% # remove trailing whitespace str_trim() %&gt;% # split on double new lines str_split(&quot;\\n\\n&quot;) %&gt;% # get the first result (input was a single vector) pluck(1) %&gt;% # iterate over these results, split on newlines map(str_split, &quot;\\n&quot;) %&gt;% # iterate over the results, select just the first item from each # (each result from str_split will be a list of character vectors) map(1) } sample &lt;- read_file(&quot;samples/day_16_sample.txt&quot;) %&gt;% process_file() actual &lt;- read_file(&quot;inputs/day_16_input.txt&quot;) %&gt;% process_file() 16.1 Part 1 First let’s build a function to process our “notes”. We can return a list containing the fields we are expecting (as a dataframe with columns for the ranges), our ticket, and the nearby tickets. process_notes &lt;- function(input) { fields &lt;- input[[1]] %&gt;% unglue_data(&quot;{field}: {a}-{b} or {c}-{d}&quot;, convert = TRUE) my_ticket &lt;- as.numeric(str_split(input[[2]][[2]], &quot;,&quot;)[[1]]) nearby_tickets &lt;- map(str_split(input[[3]][-1], &quot;,&quot;), as.numeric) list(fields = fields, my_ticket = my_ticket, nearby_tickets = nearby_tickets) } We can now process our sample and actual data. psample &lt;- process_notes(sample) pactual &lt;- process_notes(actual) psample ## $fields ## field a b c d ## 1 class 1 3 5 7 ## 2 row 6 11 33 44 ## 3 seat 13 40 45 50 ## ## $my_ticket ## [1] 7 1 14 ## ## $nearby_tickets ## $nearby_tickets[[1]] ## [1] 7 3 47 ## ## $nearby_tickets[[2]] ## [1] 40 4 50 ## ## $nearby_tickets[[3]] ## [1] 55 2 20 ## ## $nearby_tickets[[4]] ## [1] 38 6 12 Now, we need to check if a value is valid. We can build a simple function to do this that will take a value and the fields dataset. It will return TRUE if the value is valid for one of the fields and FALSE otherwise. value_is_valid &lt;- function(value, fields) { any( fields$a &lt;= value &amp; value &lt;= fields$b, fields$c &lt;= value &amp; value &lt;= fields$d ) } We now can take the nearby_tickets, flatten the nested list to a single numeric vector and discard any value that is not valid. part_1 &lt;- function(input) { input$nearby_tickets %&gt;% flatten_dbl() %&gt;% discard(value_is_valid, fields = input$fields) %&gt;% sum() } We can test with our sample data: part_1(psample) == 71 ## [1] TRUE And we can run with our actual data: part_1(pactual) ## [1] 21978 16.2 Part 2 We have a different sample for part 2: psample_2 &lt;- str_trim(&quot; class: 0-1 or 4-19 row: 0-5 or 8-19 seat: 0-13 or 16-19 your ticket: 11,12,13 nearby tickets: 3,9,18 15,1,5 5,14,9 &quot;) %&gt;% process_file() %&gt;% process_notes() For part 2 we can use {dplyr} to find the possible fields that a value could take at a position, then we can loop over the possible fields reducing the rows in the table by finding a field that is the only candidate for a position, then removing that field from other positions. This assumes that there will always be just 1 possible candidate at each point. part_2 &lt;- function(input) { valid_tickets &lt;- input$nearby_tickets %&gt;% keep(~all(map_lgl(.x, value_is_valid, fields = input$fields))) possible_fields &lt;- data.frame(value = flatten_dbl(valid_tickets), pos = 1:nrow(input$fields)) %&gt;% mutate(fields = map(value, function(.x) { input$fields %&gt;% filter((a &lt;= .x &amp; .x &lt;=b) | (c &lt;= .x &amp; .x &lt;= d)) %&gt;% pull(field) })) %&gt;% unnest_longer(col = fields) %&gt;% group_by(pos) %&gt;% count(fields) %&gt;% filter(n == max(n)) input$fields$pos &lt;- 0 while (nrow(possible_fields) &gt; 0) { f &lt;- filter(possible_fields, n() == 1) possible_fields &lt;- filter(possible_fields, fields != f$fields) input$fields[input$fields$field == f$fields, &quot;pos&quot;] &lt;- f$pos } input$fields %&gt;% select(field, pos) } We can test our function matches the provided sample: part_2(psample_2) ## field pos ## 1 class 2 ## 2 row 1 ## 3 seat 3 And now we can solve the actual problem. Find the fields and their positions, the apply those positions to my_ticket: ps &lt;- pactual %&gt;% part_2() %&gt;% filter(str_detect(field, &quot;^departure&quot;)) %&gt;% pull(pos) prod(pactual$my_ticket[ps]) ## [1] 1053686852011 "],["conway-cubes.html", "Day 17 Conway Cubes 17.1 Part 1 17.2 Part 2", " Day 17 Conway Cubes This is my attempt to solve Day 17. sample &lt;- read_lines(&quot;samples/day_17_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_17_input.txt&quot;) 17.1 Part 1 We can use the R “array” data type for today’s problem: these are n-dimensional vectors. First, let’s create a function to convert our input into a 3 dimensional array. to_array &lt;- function(input, dimensions) { if (dimensions &lt; 3) { stop(&quot;dimensions must be at least 3&quot;) } replacement &lt;- c(&quot;.&quot; = 0, &quot;#&quot; = 1) m &lt;- input %&gt;% str_extract_all(&quot;.&quot;, simplify = TRUE) %&gt;% apply(c(1,2), function(.x) replacement[[.x]]) array(m, dim = c(nrow(m), ncol(m), rep(1, dimensions - 2))) } to_array(sample, 3) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 0 1 0 ## [2,] 0 0 1 ## [3,] 1 1 1 At each iteration we need to increase the size of the state by 1 on every side. grow_state_3d &lt;- function(state) { ds &lt;- dim(state) next_state &lt;- array(0, dim = ds + 2) for (x in 1:ds[[1]]) { for (y in 1:ds[[2]]) { for (z in 1:ds[[3]]) { next_state[x + 1, y + 1, z + 1] &lt;- state[x, y, z] } } } next_state } We need a function to iterate the states according to the rules. iterate_state_3d &lt;- function(state) { state &lt;- grow_state_3d(state) ds &lt;- dim(state) next_state &lt;- state # helper function to find the bounds of the array in a given dimension: # make sure we start no lower than 1, and no higher than the size of that dim gs &lt;- function(a, i) max(1, a - 1):min(ds[[i]], a + 1) for (x in 1:ds[[1]]) { for (y in 1:ds[[2]]) { for (z in 1:ds[[3]]) { # get the bounds of the array for the dimensions xs &lt;- gs(x, 1) ys &lt;- gs(y, 2) zs &lt;- gs(z, 3) # sum the neighbours, subtract the current cell e &lt;- sum(state[xs, ys, zs]) - state[x, y, z] # apply rules if (state[x, y, z] == 1) { if (e != 2 &amp; e != 3) { next_state[x, y, z] &lt;- 0 } } else { if (e == 3) { next_state[x, y, z] &lt;- 1 } } } } } # return the iterated state next_state } We can build a helper function to run as many iterations as requested: run_n_iterations_3d &lt;- function(input, n) { reduce(1:n, ~iterate_state_3d(.x), .init = to_array(input, 3)) } Now we can check our function runs as expected sample %&gt;% run_n_iterations_3d(6) %&gt;% sum() == 112 ## [1] TRUE And we can run with our actual data actual %&gt;% run_n_iterations_3d(6) %&gt;% sum() ## [1] 368 17.2 Part 2 For part 2 we just need to extend our functions to include a 4th dimension. grow_state_4d &lt;- function(state) { ds &lt;- dim(state) next_state &lt;- array(0, dim = ds + 2) for (x in 1:ds[[1]]) { for (y in 1:ds[[2]]) { for (z in 1:ds[[3]]) { for (w in 1:ds[[4]]) { next_state[x + 1, y + 1, z + 1, w + 1] &lt;- state[x, y, z, w] } } } } next_state } iterate_state_4d &lt;- function(state) { state &lt;- grow_state_4d(state) ds &lt;- dim(state) next_state &lt;- state gs &lt;- function(a, i) max(1, a - 1):min(ds[[i]], a + 1) for (x in 1:ds[[1]]) { for (y in 1:ds[[2]]) { for (z in 1:ds[[3]]) { for (w in 1:ds[[4]]) { xs &lt;- gs(x, 1) ys &lt;- gs(y, 2) zs &lt;- gs(z, 3) ws &lt;- gs(w, 4) e &lt;- sum(state[xs, ys, zs, ws]) - state[x, y, z, w] if (state[x, y, z, w] == 1) { if (e != 2 &amp; e != 3) { next_state[x, y, z, w] &lt;- 0 } } else { if (e == 3) { next_state[x, y, z, w] &lt;- 1 } } } } } } next_state } run_n_iterations_4d &lt;- function(input, n) { reduce(1:n, ~iterate_state_4d(.x), .init = to_array(input, 4)) } We can run with our sample data to test: sample %&gt;% run_n_iterations_4d(6) %&gt;% sum() == 848 ## [1] TRUE And we can run with our actual data: actual %&gt;% run_n_iterations_4d(6) %&gt;% sum() ## [1] 2696 "],["operation-order.html", "Day 18 Operation Order 18.1 Part 1 18.2 Part 2", " Day 18 Operation Order This is my attempt to solve Day 18. sample &lt;- read_lines(&quot;samples/day_18_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_18_input.txt&quot;) 18.1 Part 1 First I think it would be useful to have a stack to solve today’s problem. This is pretty simple to construct using R6. Here I use a fixed stack size (default to 100). Stack &lt;- R6Class( &quot;Stack&quot;, public = list( initialize = function(stack_size = 100) { private$stack &lt;- vector(&quot;list&quot;, stack_size) private$stack_size &lt;- stack_size }, push = function(v) { if (self$is_full()) { stop(&quot;stack is full&quot;) } private$ptr &lt;- private$ptr + 1 private$stack[[private$ptr]] &lt;- v }, pop = function() { if (self$is_empty()) { stop(&quot;no items in stack&quot;) } v &lt;- private$stack[[private$ptr]] private$ptr &lt;- private$ptr - 1 v }, is_empty = function() { private$ptr == 0 }, is_full = function() { private$ptr == private$stack_size } ), private = list( ptr = 0, stack_size = 0, stack = NULL ) ) We can then create a function which will step through the input and add items to the stack. When we a function and a value we can update an accumulator (which we default to 0). If we reach a ( we can push the accumulator and function to the stack and reset these to the defaults. When we reach a ) we can pop the values off the stack and start using these again. part_1 &lt;- function(input) { part_1_parse &lt;- function(input) { stack &lt;- Stack$new() i &lt;- 0 acc &lt;- 0 fn &lt;- `+` while (i &lt; length(input)) { s &lt;- input[[(i &lt;- i + 1)]] if (s == &quot;(&quot;) { stack$push(acc) stack$push(fn) acc &lt;- 0 fn &lt;- `+` next() } else if (s == &quot;)&quot;) { fn &lt;- stack$pop() acc &lt;- fn(stack$pop(), acc) } else if (s == &quot;+&quot; | s == &quot;*&quot;) { fn &lt;- get(s) } else { acc &lt;- fn(acc, as.numeric(s)) } } acc } input %&gt;% str_replace_all(&quot; &quot;, &quot;&quot;) %&gt;% str_extract_all(&quot;.&quot;) %&gt;% map_dbl(part_1_parse) } We can now check out function matches the provided sample: all(part_1(sample) == c(71, 51, 26, 437, 12240, 13632)) ## [1] TRUE And we can run the function on the actual data. sum(part_1(actual)) ## [1] 69490582260 18.2 Part 2 Part 2 can make use of our stack again, but this time we first parse the data by iterating over and adding all of the values we would like to multiply to the stack. We immediately run addition and add these values to the stack instead. Our parse function this time is recursive, when we reach a ( we call our function again to parse that block. This returns the value of the accumulator and the position that we got up to. part_2 &lt;- function(input) { part_2_parse &lt;- function(input, i = 1) { stack &lt;- Stack$new() while (i &lt;= length(input)) { a &lt;- input[[i]] # we have found a bracket, escape loop if (a == &quot;)&quot;) break() if (a == &quot;(&quot;) { p &lt;- part_2_parse(input, i + 1) # add value from inside bracket to stack stack$push(as.numeric(p[[1]])) # skip to matching parenthesis i &lt;- p[[2]] } else if (a == &quot;+&quot;) { i &lt;- i + 1 b &lt;- input[[i]] if (b == &quot;(&quot;) { p &lt;- part_2_parse(input, i + 1) b &lt;- as.numeric(p$acc) i &lt;- p$i } av &lt;- stack$pop() bv &lt;- as.numeric(b) stack$push(av + bv) } else if (a == &quot;*&quot;) { i &lt;- i + 1 b &lt;- input[[i]] if (b == &quot;(&quot;) { p &lt;- part_2_parse(input, i + 1) b &lt;- as.numeric(p$acc) i &lt;- p$i } bv &lt;- as.numeric(b) stack$push(bv) } else { stack$push(as.numeric(a)) } i &lt;- i + 1 } acc &lt;- 1 while (!stack$is_empty()) { acc &lt;- acc * stack$pop() } # return the accumulated value and the index we got to list(acc = acc, i = i) } input %&gt;% str_replace_all(&quot; &quot;, &quot;&quot;) %&gt;% str_extract_all(&quot;.&quot;) %&gt;% map(part_2_parse) %&gt;% map_dbl(&quot;acc&quot;) } We can now check out function matches the provided sample: all(part_2(sample) == c(231, 51, 46, 1445, 669060, 23340)) ## [1] TRUE And we can run the function on the actual data. sum(part_2(actual)) ## [1] 362464596624526 "],["monster-messages.html", "Day 19 Monster Messages 19.1 Part 1 19.2 Part 2", " Day 19 Monster Messages This is my attempt to solve Day 19. This is a work in progress: part 1 works, part 2 gives an incorrect result. process_file &lt;- function(file) { read_file(file) %&gt;% str_trim() %&gt;% str_remove_all(&quot;\\r&quot;) %&gt;% str_split(&quot;\\n\\n&quot;) %&gt;% pluck(1) %&gt;% map(str_split, &quot;\\n&quot;) %&gt;% map(1) } sample &lt;- process_file(&quot;samples/day_19_sample.txt&quot;) actual &lt;- process_file(&quot;inputs/day_19_input.txt&quot;) 19.1 Part 1 First let’s create a function to process a rule against the current message. r is the rule we are currently processing and defaults to “0”, m is the character index in message that we are currently processing. If we do not match the message we return NA, othwerwise we return the postion that we have reached in the message. fn &lt;- function(rules, message, r = &quot;0&quot;, m = 1) { if (m &gt; length(message)) return (as.numeric(NA)) if (str_detect(rules[[r]], &quot;^\\\\w$&quot;)) { return (if (rules[[r]] == message[[m]]) m + 1 else as.numeric(NA)) } for (i in str_split(rules[[r]], &quot; \\\\| &quot;)[[1]]) { mx &lt;- m for (j in str_split(i, &quot; &quot;)[[1]]) { mx &lt;- fn(rules, message, j, mx) if (is.na(mx)) break() } if (!is.na(mx)) return (mx) } return (as.numeric(NA)) } Now we just need to process our input to split into rules and messages, and then call our function. part_1 &lt;- function(input) { rules &lt;- local({ a &lt;- input[[1]] %&gt;% str_replace_all(&quot;\\&quot;&quot;, &quot;&quot;) %&gt;% str_split(&quot;: &quot;) %&gt;% transpose() set_names(a[[2]], a[[1]]) }) messages &lt;- input[[2]] %&gt;% str_extract_all(&quot;.&quot;) m &lt;- map_dbl(messages, fn, rules = rules) sum(map_dbl(messages, length) == m - 1, na.rm = TRUE) } We can test our function matches the sample: part_1(sample) == 2 ## [1] TRUE And we can run with our actual data: part_1(actual) ## [1] 173 19.2 Part 2 This is a work in progress, it’s not giving the correct result. part_2 &lt;- function(input) { rules &lt;- local({ a &lt;- input[[1]] %&gt;% str_replace_all(&quot;\\&quot;&quot;, &quot;&quot;) %&gt;% str_split(&quot;: &quot;) %&gt;% transpose() set_names(a[[2]], a[[1]]) }) rules[[&quot;8&quot;]] &lt;- &quot;42 | 42 8&quot; rules[[&quot;11&quot;]] &lt;- &quot;42 31 | 42 11 31&quot; messages &lt;- input[[2]] %&gt;% str_extract_all(&quot;.&quot;) m &lt;- map_dbl(messages, fn, rules = rules) sum(map_dbl(messages, length) == m - 1, na.rm = TRUE) } part_2_sample &lt;- list(c( &quot;42: 9 14 | 10 1&quot;, &quot;9: 14 27 | 1 26&quot;, &quot;10: 23 14 | 28 1&quot;, &quot;1: \\&quot;a\\&quot;&quot;, &quot;11: 42 31&quot;, &quot;5: 1 14 | 15 1&quot;, &quot;19: 14 1 | 14 14&quot;, &quot;12: 24 14 | 19 1&quot;, &quot;16: 15 1 | 14 14&quot;, &quot;31: 14 17 | 1 13&quot;, &quot;6: 14 14 | 1 14&quot;, &quot;2: 1 24 | 14 4&quot;, &quot;0: 8 11&quot;, &quot;13: 14 3 | 1 12&quot;, &quot;15: 1 | 14&quot;, &quot;17: 14 2 | 1 7&quot;, &quot;23: 25 1 | 22 14&quot;, &quot;28: 16 1&quot;, &quot;4: 1 1&quot;, &quot;20: 14 14 | 1 15&quot;, &quot;3: 5 14 | 16 1&quot;, &quot;27: 1 6 | 14 18&quot;, &quot;14: \\&quot;b\\&quot;&quot;, &quot;21: 14 1 | 1 14&quot;, &quot;25: 1 1 | 1 14&quot;, &quot;22: 14 14&quot;, &quot;8: 42&quot;, &quot;26: 14 22 | 1 20&quot;, &quot;18: 15 15&quot;, &quot;7: 14 5 | 1 21&quot;, &quot;24: 14 1&quot; ), c( &quot;abbbbbabbbaaaababbaabbbbabababbbabbbbbbabaaaa&quot;, &quot;bbabbbbaabaabba&quot;, &quot;babbbbaabbbbbabbbbbbaabaaabaaa&quot;, &quot;aaabbbbbbaaaabaababaabababbabaaabbababababaaa&quot;, &quot;bbbbbbbaaaabbbbaaabbabaaa&quot;, &quot;bbbababbbbaaaaaaaabbababaaababaabab&quot;, &quot;ababaaaaaabaaab&quot;, &quot;ababaaaaabbbaba&quot;, &quot;baabbaaaabbaaaababbaababb&quot;, &quot;abbbbabbbbaaaababbbbbbaaaababb&quot;, &quot;aaaaabbaabaaaaababaa&quot;, &quot;aaaabbaaaabbaaa&quot;, &quot;aaaabbaabbaaaaaaabbbabbbaaabbaabaaa&quot;, &quot;babaaabbbaaabaababbaabababaaab&quot;, &quot;aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba&quot; )) part_1(part_2_sample) == 3 ## [1] TRUE part_2(part_2_sample) ## [1] 6 part_2(actual) ## [1] 221 "],["jurassic-jigsaw.html", "Day 20 Jurassic Jigsaw 20.1 Part 1 20.2 Part 2", " Day 20 Jurassic Jigsaw This is my attempt to solve Day 20. process_file &lt;- function(file) { f &lt;- read_file(file) %&gt;% str_trim() %&gt;% str_remove_all(&quot;\\r&quot;) %&gt;% str_split(&quot;\\n\\n&quot;) %&gt;% pluck(1) %&gt;% str_split(&quot;\\n&quot;) t &lt;- f %&gt;% map(1) %&gt;% str_extract(&quot;\\\\d+&quot;) f %&gt;% set_names(t) %&gt;% map(~ str_extract_all(.x[-1], &quot;.&quot;, simplify = TRUE)) } sample &lt;- process_file(&quot;samples/day_20_sample.txt&quot;) actual &lt;- process_file(&quot;inputs/day_20_input.txt&quot;) 20.1 Part 1 We can solve part 1 by looking which pieces have edges that don’t have any matches to other pieces. get_edges &lt;- function(.x) c( paste(.x[ 1, 1:10], collapse = &quot;&quot;), paste(.x[ 1, 10:1], collapse = &quot;&quot;), paste(.x[10, 1:10], collapse = &quot;&quot;), paste(.x[10, 10:1], collapse = &quot;&quot;), paste(.x[1:10, 1], collapse = &quot;&quot;), paste(.x[10:1, 1], collapse = &quot;&quot;), paste(.x[1:10, 10], collapse = &quot;&quot;), paste(.x[10:1, 10], collapse = &quot;&quot;) ) find_corners &lt;- function(edges) { names(edges)[imap(edges, function(.x, .i) { other_edges &lt;- flatten_chr(edges[names(edges) != .i]) length(other_edges[other_edges %in% .x]) }) == 4] } We can now simply find the corner pieces for our input. part_1 &lt;- function(input) { edges &lt;- map(input, get_edges) corners &lt;- find_corners(edges) prod(as.numeric(corners)) } We can run this function with the sample data: part_1(sample) == 20899048083289 ## [1] TRUE We can now run this with our actual data: part_1(actual) ## [1] 174206308298779 20.2 Part 2 We now need to fully construct the image. First we can produce a function which takes a piece and returns all of the 8 reflections and rotations of that image (identity, 90/180/270 degree rotations, horizontal/vertical reflections and the corner-to-corner reflections). get_rotations_and_reflections &lt;- function(i) { rot90 &lt;- function(m) { matrix(m[matrix(c(rep(10:1, each = 10), rep(1:10, 10)), ncol = 2)], ncol = 10, nrow = 10) } ret &lt;- list(i = i) ret$a &lt;- rot90(i) # 90 deg ret$b &lt;- rot90(ret$a) # 180 deg ret$c &lt;- rot90(ret$b) # 270 deg ret$d &lt;- i[1:10, 10:1] # horizontal reflection ret$e &lt;- i[10:1, 1:10] # vertical reflection ret$f &lt;- rot90(rot90(rot90(ret$d))) # TLBR reflection ret$g &lt;- rot90(rot90(rot90(ret$e))) # BLTR reflection ret } We also can create a function like the function for finding corners to find the outside edges. find_outside_edges &lt;- function(edges) { names(edges)[imap(edges, function(.x, .i) { other_edges &lt;- flatten_chr(edges[names(edges) != .i]) length(other_edges[other_edges %in% .x]) }) == 6] } Solving part 2 is now pretty tedious. First, we find the corners and outside edges. We select a corner and place it in the top left corner. Then, we iterate from left to right on the top row finding the single piece that matches (hoping that there are unique pieces and we don’t need to implement a backtracking algorithm). We then can find the next corner piece and repeat for for the other edges. Once we have found the edges, we can fill in the inside of the image, and then we can construct the image without the borders. Then we can simply move from left to right, top to bottom scanning for the sea monsters. If we find a sea monster we can decrease a counter. We simply return the counter as the final result. part_2 &lt;- function(input) { size &lt;- sqrt(length(input)) edges &lt;- map(input, get_edges) corners &lt;- find_corners(edges) outside_edges &lt;- find_outside_edges(edges) inside_pieces &lt;- names(edges) %&gt;% discard(~ .x %in% c(corners, outside_edges)) all_orientations &lt;- map(input, get_rotations_and_reflections) full_map_pieces &lt;- matrix(&quot;&quot;, nrow = size, ncol = size) full_map_orientations &lt;- matrix(&quot;&quot;, nrow = size, ncol = size) # complete top row # pick top left corner, choose first corner tl &lt;- corners[[1]] # remove this corner corners &lt;- corners[-1] tl_outside_edges &lt;- edges[[tl]] %&gt;% discard(~ .x %in% flatten_chr(edges[names(edges) != tl])) # we will find two options here, one will just be a reflecion in the diagonal # so we can discard tlo &lt;- all_orientations[[tl]] %&gt;% keep(~ paste(.x[1,], collapse = &quot;&quot;) %in% tl_outside_edges) %&gt;% keep(~ paste(.x[,1], collapse = &quot;&quot;) %in% tl_outside_edges) %&gt;% names() %&gt;% pluck(1) full_map_pieces[1, 1] &lt;- j &lt;- tl full_map_orientations[1, 1] &lt;- k &lt;- tlo # now, fill in top row: assumes a single result is found for (i in 2:(size - 1)) { t &lt;- paste(all_orientations[[j]][[k]][,10], collapse = &quot;&quot;) r &lt;- all_orientations[outside_edges] %&gt;% map_depth(2, ~paste(.x[,1], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[1, i] &lt;- j &lt;- names(r) full_map_orientations[1, i] &lt;- k &lt;- names(r[[1]]) # remove edge outside_edges &lt;- outside_edges[outside_edges != j] } # add in top right corner t &lt;- paste(all_orientations[[j]][[k]][,10], collapse = &quot;&quot;) r &lt;- all_orientations[corners] %&gt;% map_depth(2, ~paste(.x[,1], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[1, size] &lt;- j &lt;- names(r) full_map_orientations[1, size] &lt;- k &lt;- names(r[[1]]) # remove corner corners &lt;- corners[corners != j] # yuck, repeat for right, then bottom, then bottom for (i in 2:(size - 1)) { t &lt;- paste(all_orientations[[j]][[k]][10,], collapse = &quot;&quot;) r &lt;- all_orientations[outside_edges] %&gt;% map_depth(2, ~paste(.x[1,], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[i, size] &lt;- j &lt;- names(r) full_map_orientations[i, size] &lt;- k &lt;- names(r[[1]]) # remove edge outside_edges &lt;- outside_edges[outside_edges != j] } # add in bottom right corner t &lt;- paste(all_orientations[[j]][[k]][10,], collapse = &quot;&quot;) r &lt;- all_orientations[corners] %&gt;% map_depth(2, ~paste(.x[1,], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[size, size] &lt;- j &lt;- names(r) full_map_orientations[size, size] &lt;- k &lt;- names(r[[1]]) # remove corner corners &lt;- corners[corners != j] # do bottom row for (i in (size - 1):2) { t &lt;- paste(all_orientations[[j]][[k]][,1], collapse = &quot;&quot;) r &lt;- all_orientations[outside_edges] %&gt;% map_depth(2, ~paste(.x[,10], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[size, i] &lt;- j &lt;- names(r) full_map_orientations[size, i] &lt;- k &lt;- names(r[[1]]) # remove edge outside_edges &lt;- outside_edges[outside_edges != j] } # bottom left corner is last remaining now. We just need to find it&#39;s # orientation t &lt;- paste(all_orientations[[j]][[k]][,1], collapse = &quot;&quot;) r &lt;- all_orientations[corners] %&gt;% map_depth(2, ~paste(.x[,10], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[size, 1] &lt;- j &lt;- names(r) full_map_orientations[size, 1] &lt;- k &lt;- names(r[[1]]) # finally, fill in left edge for (i in (size - 1):2) { t &lt;- paste(all_orientations[[j]][[k]][1,], collapse = &quot;&quot;) r &lt;- all_orientations[outside_edges] %&gt;% map_depth(2, ~paste(.x[10,], collapse = &quot;&quot;)) %&gt;% map(keep, ~.x == t) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[i, 1] &lt;- j &lt;- names(r) full_map_orientations[i, 1] &lt;- k &lt;- names(r[[1]]) # remove edge outside_edges &lt;- outside_edges[outside_edges != j] } inside_pieces # now, fill in centre. for (i in 2:(size - 1)) { for (j in 2:(size - 1)) { aj &lt;- full_map_pieces[i, j - 1] ak &lt;- full_map_orientations[i, j - 1] a &lt;- paste(all_orientations[[aj]][[ak]][,10], collapse = &quot;&quot;) bj &lt;- full_map_pieces[i - 1, j] bk &lt;- full_map_orientations[i - 1, j] b &lt;- paste(all_orientations[[bj]][[bk]][10,], collapse = &quot;&quot;) r &lt;- all_orientations[inside_pieces] %&gt;% map(keep, ~paste(.x[,1], collapse = &quot;&quot;) == a) %&gt;% map(keep, ~paste(.x[1,], collapse = &quot;&quot;) == b) %&gt;% discard(~length(.x) == 0) stopifnot(length(r) == 1, length(r[[1]]) == 1) full_map_pieces[i, j] &lt;- names(r) full_map_orientations[i, j] &lt;- names(r[[1]]) # remove edge inside_pieces &lt;- inside_pieces[inside_pieces != full_map_pieces[i, j]] } } # we can now reconstruct the image: we need to remove the border&#39;s from the images image &lt;- matrix(nrow = size * 8, ncol = size * 8) for (i in 1:size) { for (j in 1:size) { istart &lt;- (i - 1) * 8 jstart &lt;- (j - 1) * 8 aj &lt;- full_map_pieces[i, j ] ak &lt;- full_map_orientations[i, j] current &lt;- all_orientations[[aj]][[ak]][2:9, 2:9] image[istart:(istart + 7) + 1, jstart:(jstart + 7) + 1] &lt;- current } } sea_monster &lt;- local({ t &lt;- c(&quot; # &quot;, &quot;# ## ## ###&quot;, &quot; # # # # # # &quot;) %&gt;% str_extract_all(&quot;.&quot;, simplify = TRUE) which(t == &quot;#&quot;, TRUE) - 1 }) # iterate over the image, count how many cells are sea monsters count &lt;- sum(image == &quot;#&quot;) # hard code in size of sea monster for (i in 1:(nrow(image) - 3)) { for (j in 1:(ncol(image) - 20)) { ix &lt;- sea_monster ix[,1] &lt;- ix[,1] + i ix[,2] &lt;- ix[,2] + j t &lt;- image[ix] == &quot;#&quot; if (all(t)) { count &lt;- count - sum(t) } } } count } We can run the function now on the sample: part_2(sample) ## [1] 273 And we can run for our actual data: part_2(actual) ## [1] 2409 This felt rather tedious and procedural, perhaps there is a neater solution. Improvements could be made to my code by extracting some of the repeated logic into functions. "],["allergen-assessment.html", "Day 21 Allergen Assessment 21.1 Part 1 21.2 Part 2", " Day 21 Allergen Assessment This is my attempt to solve Day 21. sample &lt;- read_lines(&quot;samples/day_21_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_21_input.txt&quot;) 21.1 Part 1 First, let’s build a function which takes the input and return’s all of the possible combinations (the “cross product”) of ingredients and allergens. ingredient_allergen_combinations &lt;- function(input) { input %&gt;% str_remove_all(&quot;contains |\\\\)&quot;) %&gt;% str_split(&quot; \\\\(&quot;) %&gt;% map_dfr(~list( ingredient = str_split(.x[[1]], &quot; &quot;)[[1]], allergen = str_split(.x[[2]], &quot;, &quot;)[[1]] ) %&gt;% cross_df(), .id = &quot;food&quot;) } Next we need to find for each allergen which ingredients could be that allergen. We can do this by simply counting the allergen’s and ingredients, then for each allergen filter out all of the ingredients which don’t appear in every food. Here we do this by grouping by allergen’s and then filtering the n column (created by count()) to only include rows which are equal to the maximum value. get_allergen_ingredients &lt;- function(data) { data %&gt;% group_by(allergen) %&gt;% count(ingredient) %&gt;% filter(n == max(n)) %&gt;% ungroup() } We can now put this together to solve part 1. We simply need to take the data frame containing all of the foods and their ingredients, find the possibly ingredients for each allergen, and then remove these from the data frame. part_1 &lt;- function(input) { df &lt;- ingredient_allergen_combinations(input) allergen_ingredients &lt;- df %&gt;% get_allergen_ingredients() %&gt;% distinct(ingredient) df %&gt;% anti_join(allergen_ingredients, by = &quot;ingredient&quot;) %&gt;% distinct(food, ingredient) %&gt;% nrow() } We can test our function works against the sample: part_1(sample) == 5 ## [1] TRUE And we can run our function on the actual data: part_1(actual) ## [1] 2307 21.2 Part 2 For part 2 we can reuse the functions we created in part 1 and use the {igraph} package to create a bipartite graph of the ingredients and allergen’s, then find the maximum bipartite match for this graph. This will give us our answer. part_2 &lt;- function(input) { df &lt;- ingredient_allergen_combinations(input) allergen_ingredients &lt;- df %&gt;% get_allergen_ingredients() vertices &lt;- bind_rows( tibble(name = unique(allergen_ingredients$ingredient), type = 1), tibble(name = unique(allergen_ingredients$allergen), type = 0) ) g &lt;- allergen_ingredients %&gt;% select(-n) %&gt;% graph_from_data_frame(vertices = vertices) m &lt;- max_bipartite_match(g)$matching paste(m[sort(filter(vertices, type == 0)$name)], collapse = &quot;,&quot;) } We can test that our function works on the provided sample data: part_2(sample) == &quot;mxmxvkd,sqjhc,fvjkl&quot; ## [1] TRUE And we can run our function on the actual data: part_2(actual) ## [1] &quot;cljf,frtfg,vvfjj,qmrps,hvnkk,qnvx,cpxmpc,qsjszn&quot; "],["crab-combat.html", "Day 22 Crab Combat 22.1 Part 1 22.2 Part 2", " Day 22 Crab Combat This is my attempt to solve Day 22. process_file &lt;- function(file) { read_file(file) %&gt;% str_trim() %&gt;% str_remove_all(&quot;\\r&quot;) %&gt;% str_split(&quot;\\n\\n&quot;) %&gt;% pluck(1) %&gt;% map(~as.numeric(str_split(.x, &quot;\\n&quot;)[[1]][-1])) } sample &lt;- process_file(&quot;samples/day_22_sample.txt&quot;) actual &lt;- process_file(&quot;inputs/day_22_input.txt&quot;) 22.1 Part 1 We can create a function that applies the rules of the game. part_1 &lt;- function(input) { player_1 &lt;- input[[1]] player_2 &lt;- input[[2]] # repeat while both players have cards while(length(player_1) &gt; 0 &amp; length(player_2) &gt; 0) { # get the first cards for player 1 and player 2 a &lt;- player_1[[1]] b &lt;- player_2[[1]] # and remove the first cards player_1 &lt;- player_1[-1] player_2 &lt;- player_2[-1] if (a &gt; b) { player_1 &lt;- c(player_1, a, b) } else { player_2 &lt;- c(player_2, b, a) } } # get the winners cards r &lt;- if (length(player_1) &gt; 0) { player_1 } else { player_2 } # return the results as required for the puzzle sum(r * rev(seq_along(r))) } We can verify that this function returns the correct results against the sample data: part_1(sample) == 306 ## [1] TRUE And we can run the function against our actual data: part_1(actual) ## [1] 35818 22.2 Part 2 Part 2 is a more complex problem. The naive implementation takes a number of minutes to run, but there is a useful optimisation that u/daggerdraggon posted on Reddit. part_2 &lt;- function(input) { # create a function that can called recursively play &lt;- function(player_1, player_2, subgame = FALSE) { prior_player_1 &lt;- list() prior_player_2 &lt;- list() # optimisation from u/daggerdragon on reddit # https://www.reddit.com/r/adventofcode/comments/khyjgv/2020_day_22_solutions/ggpcsnd/ max_p1 &lt;- max(player_1) max_p2 &lt;- max(player_2) if (subgame &amp;&amp; max_p1 &gt; max_p2 &amp;&amp; (length(player_1) + length(player_2)) &lt; max_p1) { return (list( winner = 1, players = list(player_1, player_2) )) } # repeat while both players have cards while(length(player_1) &gt; 0 &amp; length(player_2) &gt; 0) { # create key&#39;s to use in the hash of the prior hands seen hashtables player_1_str &lt;- paste(player_1, collapse = &quot;,&quot;) player_2_str &lt;- paste(player_2, collapse = &quot;,&quot;) # check, if we haven&#39;t seen this hand we will get NULL on lookups # looking up like this is orders of magnitude quicker than using %in% if (!is.null(prior_player_1[[player_1_str]]) &amp; !is.null(prior_player_2[[player_2_str]])) { return (list( winner = 1, players = list(player_1, player_2) )) } # update the prior seen hashtables prior_player_1[[player_1_str]] &lt;- TRUE prior_player_2[[player_2_str]] &lt;- TRUE # get the first cards for player 1 and player 2 a &lt;- player_1[[1]] b &lt;- player_2[[1]] # and remove the first cards player_1 &lt;- player_1[-1] player_2 &lt;- player_2[-1] # check to see if we can play a subgame or not r &lt;- if (length(player_1) &gt;= a &amp; length(player_2) &gt;= b) { # return the winner of the subgame play(player_1[1:a], player_2[1:b], TRUE)$winner } else if (a &gt; b) { # player 1 wins 1 } else { # player 2 wins 2 } # update the player&#39;s hands if they have won if (r == 1) { player_1 &lt;- c(player_1, a, b) } else { player_2 &lt;- c(player_2, b, a) } } # we have run out of cards for one player, return the results list( winner = ifelse(length(player_1) &gt; 0, 1, 2), players = list(player_1, player_2) ) } # start to play the game p &lt;- play(input[[1]], input[[2]]) # get the results for the winner w &lt;- p$players[[p$winner]] # return the results as required for the puzzle sum(w * rev(seq_along(w))) } We can test this function on the sample data: part_2(sample) == 291 ## [1] TRUE And we can run this function on the actual data: part_2(actual) ## [1] 34771 "],["crab-cups.html", "Day 23 Crab Cups 23.1 Part 1 23.2 Part 2", " Day 23 Crab Cups This is my attempt to solve Day 23. sample &lt;- as.numeric(str_extract_all(&quot;389125467&quot;, &quot;.&quot;)[[1]]) actual &lt;- as.numeric(str_extract_all(&quot;562893147&quot;, &quot;.&quot;)[[1]]) 23.1 Part 1 To solve today’s puzzle we can use a vector where each position’s value indicates the next index to select. First we create our “linked list” of values, then create a “current” pointer (where we are going to start in the list). Then, we simply iterate n times. play &lt;- function(input, n) { size &lt;- length(input) # generate the linked list ll &lt;- c(2:size, 1) j &lt;- size for (i in input) { ll[[j]] &lt;- i j &lt;- i } ll[[j]] &lt;- input[[1]] cur &lt;- input[[1]] # run our iterations for (i in 1:n) { # get the picked up values picked_up_a &lt;- ll[[cur]] picked_up_b &lt;- ll[[picked_up_a]] picked_up_c &lt;- ll[[picked_up_b]] # &quot;remove&quot; these values from the list by pointing the current index to be # the value just after the 3rd picked up cup ll[[cur]] &lt;- ll[[picked_up_c]] # calculate the destination value destination &lt;- cur - 1 if (destination == 0) { destination &lt;- size } while (destination == picked_up_a || destination == picked_up_b || destination == picked_up_c) { destination &lt;- destination - 1 if (destination == 0) { destination &lt;- size } } # insert the picked up cups just after the destination t &lt;- ll[[destination]] ll[[destination]] &lt;- picked_up_a ll[[picked_up_c]] &lt;- t # move to the next cups cur &lt;- ll[[cur]] } # return the linked list ll } We can now use our play() function to solve part 1. part_1 &lt;- function(input, n) { # run the function on our input r &lt;- play(input, n) # create an out vector the length of our input, excluding the &quot;1&quot; value out &lt;- numeric(length(input) - 1) # now, iterate from the &quot;1&quot; position through the linked list, adding the # values to the output and selecting the next item in the linked list j &lt;- 1 for (i in seq_along(out)) { out[[i]] &lt;- r[[j]] j &lt;- r[[j]] } # return as a string paste(out, collapse = &quot;&quot;) } We can test that our function works against the sample data: part_1(sample, 10) == &quot;92658374&quot; ## [1] TRUE part_1(sample, 100) == &quot;67384529&quot; ## [1] TRUE And we can run our function against the actual data: part_1(actual, 100) ## [1] &quot;38925764&quot; 23.2 Part 2 We don’t need to modify our play function, merely we need to add in the remaining cups from 10 to 1,000,000. part_2 &lt;- function(input) { input &lt;- c(input, (max(input) + 1):1000000) r &lt;- play(input, 10000000) a &lt;- r[[1]] b &lt;- r[[a]] a * b } We can test that this function works on the provided sample: part_2(sample) == 149245887792 ## [1] TRUE And we can run the function on our actual data: part_2(actual) ## [1] 131152940564 "]]
