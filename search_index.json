[["index.html", "Advent of Code 2020 Advent of Code 2020", " Advent of Code 2020 Tom Jemmett 2020-12-02 Advent of Code 2020 This is my attempt to complete the Advent of Code 2020 in R. "],["report-repair.html", "Day 1 Report Repair 1.1 Part 1 1.2 Part 2", " Day 1 Report Repair This is my attempt to solve Day 1. sample &lt;- c(1721, 979, 366, 299, 675, 1456) actual &lt;- read_lines(&quot;day_01_input.txt&quot;) %&gt;% as.integer() 1.1 Part 1 The naive approach to solving today’s problem is to simple loop through the list twice, checking to see if the condition is met. If it is, immediately return that value. If we reach the end of both loops without finding the solution we can return NULL to indicate no result found. part_1_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input)-1)) { for (j in (i+1):length(input)) { if (input[[i]] + input[[j]] == target) return (input[[i]] * input[[j]]) } } NULL } We can test that this method works: part_1_naive(sample, 2020) == 514579 ## [1] TRUE This approach could be improved, we can sort the list, then create two pointers: the start and end of the list. If we add these two numbers up and exceed the target then we can decrease the higher number pointer. If the number is lower that the target we increase the lower number pointer. part_1_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) i &lt;- 1 j &lt;- length(input) input &lt;- sort(input) while (i &lt;= j) { v &lt;- input[[i]] + input[[j]] if (v == target) { return (input[[i]] * input[[j]]) } else if (v &lt; target) { i &lt;- i + 1 } else { j &lt;- j - 1 } } NULL } Again, we can test that this method works. part_1_improved(sample, 2020) == 514579 ## [1] TRUE We can now use our improved algorithm to get the result for part 1: part_1_improved(actual, 2020) ## [1] 793524 1.1.1 is the improved algorithm any better? bench::mark(part_1_naive(sample, 2020), part_1_improved(sample, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_1_naive(sample, 2020) 2.66µs 3.38µs [4m2[24m[4m5[24m[4m8[24m270. 0B 25.8 ## [90m2[39m part_1_improved(sample, 2020) 60.44µs 65.68µs [4m1[24m[4m4[24m804. 0B 17.0 For me, the improved algorithm actually takes longer on the sample data! This is because the improved algorithm has to sort the data, which is costly, and then it performs far more comparisons per iteration. However, when we have more data, these extra steps lead to big improvements, as can be seen when running with the actual data. bench::mark(part_1_naive(actual, 2020), part_1_improved(actual, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_1_naive(actual, 2020) 700µs 711.7µs [4m1[24m325. 0B 2.02 ## [90m2[39m part_1_improved(actual, 2020) 85.2µs 89.7µs [4m1[24m[4m0[24m679. 1.66KB 14.9 The improved algorithm was roughly 10x faster for me on the actual data. 1.2 Part 2 We can alter the naive approach from part 1 by adding in an extra for loop. part_2_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input) - 2)) { for (j in (i + 1):(length(input) - 1)) { for (k in (j + 1):length(input)) { if (input[[i]] + input[[j]] + input[[k]] == target) return (prod(input[c(i, j, k)])) } } } NULL } Again, we can test that this method works on the sample. part_2_naive(sample, 2020) == 241861950 ## [1] TRUE It’s much harder to adapt the improved algorithm though. My best approach involves a binary search. This function takes a sorted array, a target value, a current index into the array, and the current min/max extents to search. If the value at position i in array is less than target, we look in the left half of the array, chopping it in half by reducing max. Likewise, if the value is greater than target, we look in the right half of the array, chopping it in half by increasing min. binary_search &lt;- function(arr, target, i, min, max) { if (arr[[i]] == target) { return(i) } else if (target &lt; arr[[i]]) { max &lt;- i ni &lt;- (min + i) %/% 2 } else { min &lt;- i ni &lt;- (max + i) %/% 2 } if (ni == i) { NULL } else { binary_search(arr, target, ni, min, max) } } Our improved algorithm for part 2 involves creating two for loops to search from the end of the (sorted) input. We then remove the third loop by using a binary search to find the target value quicker. In the two for loops we first calculate the value of the adding these two items together, quickly checking to see if there is a possible solution (and exiting early if not). Then, we perform a binary search on the rest of the array for the amount required to make v equal target (2020). If we find the value, then we simply return the results. Else we continue the search by looping. part_2_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) input &lt;- sort(input) for (j in length(input):3) { for (i in (j - 1):2) { v &lt;- sum(input[c(i, j)]) # early termination if (v &gt;= target) next() if (v + input[[i - 1]] &lt; target) next() # binary search for a suitable value k &lt;- binary_search(input, target - v, (i + 1) %/% 2, 1, (i - 1)) if (!is.null(k)) { return (prod(input[c(i, j, k)])) } } } NULL } We can once again test that our method works on the sample data: part_2_improved(sample, 2020) == 241861950 ## [1] TRUE We can now run both approaches to see what the result is: part_2_naive(actual, 2020) ## [1] 61515678 part_2_improved(actual, 2020) ## [1] 61515678 1.2.1 Is our improved algorithm better this time? Once again, we can benchmark the two approaches. bench::mark(part_2_naive(actual, 2020), part_2_improved(actual, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_2_naive(actual, 2020) 110.3ms 111.3ms 8.98 0B 2.25 ## [90m2[39m part_2_improved(actual, 2020) 15.1ms 15.1ms 66.0 1.66KB 793. On my machine the improved approach is again about 10x quicker, though there are more memory allocations and GC (garbage collection’s) happening, so the total execution time is not quite 10x. "],["password-philosophy.html", "Day 2 Password Philosophy 2.1 Part 1 2.2 Part 2", " Day 2 Password Philosophy This is my attempt to solve Day 2. sample &lt;- c(&quot;1-3 a: abcde&quot;, &quot;1-3 b: cdefg&quot;, &quot;2-9 c: ccccccccc&quot;) actual &lt;- read_lines(&quot;day_02_input.txt&quot;) 2.1 Part 1 We need to convert each string into a list that contains the following: minimum number of occurrences of the character maximum number of occurrences of the character the character that must be present the password split_input &lt;- function(input) { input %&gt;% # first, split the string into the bit before the password, and the password str_split(&quot;: &quot;) %&gt;% # now, we can iterate over the results (each line of data) map(function(.x) { # find the min/max values from the first part of the input string .x mv &lt;- .x[[1]] %&gt;% # we can remove the last 2 characters of the string (the character) str_sub(1, -3) %&gt;% # now we can split the string into the min and max values str_split(&quot;-&quot;) %&gt;% # str_split is vectorised, but we only want the first results as we are dealing with one line at a time: # the first result will contain two values pluck(1) %&gt;% # now convert these to integers as.integer() # we can now return the results list( min = mv[[1]], max = mv[[2]], character = str_sub(.x[[1]], -1, -1), password = .x[[2]] ) }) } We can see what our split_input function does to the sample data, looking at just the first item str(split_input(sample)[[1]]) ## List of 4 ## $ min : int 1 ## $ max : int 3 ## $ character: chr &quot;a&quot; ## $ password : chr &quot;abcde&quot; Now we can build a function to return the valid passwords. part_1_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # extract the matching values from the string, we can then count the size of the vector to find how many times that # character appeared in the string lp &lt;- length(str_extract_all(i$password, i$character)[[1]]) # check to see if the password is valid i$min &lt;= lp &amp; lp &lt;= i$max } input %&gt;% split_input() %&gt;% # run the is_valid function on each of the input values, keeping only the valid passwords keep(is_valid) %&gt;% # pull out the password value from each of the lists map_chr(&quot;password&quot;) } part_1_valid_passwords(sample) ## [1] &quot;abcde&quot; &quot;ccccccccc&quot; This matches with the example given on the AOC website. We can now try to solve the first part: length(part_1_valid_passwords(actual)) ## [1] 493 2.2 Part 2 We can use the split_input function again, but modifiy the is_valid function slightly. part_2_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # as per part 1, but this time extract the characters in the password at position min and max a &lt;- str_sub(i$password, i$min, i$min) == i$character b &lt;- str_sub(i$password, i$max, i$max) == i$character # we can now xor these values: if both a and b are true xor = FASLE xor(a, b) } input %&gt;% split_input() %&gt;% keep(is_valid) %&gt;% map_chr(&quot;password&quot;) } part_2_valid_passwords(sample) ## [1] &quot;abcde&quot; This matches the example, so we can now solve part 2. length(part_2_valid_passwords(actual)) ## [1] 593 "]]
