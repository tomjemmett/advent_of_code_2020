[["index.html", "Advent of Code 2020 Introduction", " Advent of Code 2020 Tom Jemmett 2020-12-03 Introduction This is my attempt to complete the Advent of Code 2020 in R using RMarkdown, along with bookdown to render the site. The book will automatically be rebuilt using GitHub actions and hosted using GitHub Pages. "],["report-repair.html", "Day 1 Report Repair 1.1 Part 1 1.2 Part 2", " Day 1 Report Repair This is my attempt to solve Day 1. sample &lt;- read_lines(&quot;samples/day_01_sample.txt&quot;) %&gt;% as.integer() actual &lt;- read_lines(&quot;inputs/day_01_input.txt&quot;) %&gt;% as.integer() 1.1 Part 1 The naive approach to solving today’s problem is to simple loop through the list twice, checking to see if the condition is met. If it is, immediately return that value. If we reach the end of both loops without finding the solution we can return NULL to indicate no result found. part_1_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input)-1)) { for (j in (i+1):length(input)) { if (input[[i]] + input[[j]] == target) return (input[[i]] * input[[j]]) } } NULL } We can test that this method works: part_1_naive(sample, 2020) == 514579 ## [1] TRUE This approach could be improved, we can sort the list, then create two pointers: the start and end of the list. If we add these two numbers up and exceed the target then we can decrease the higher number pointer. If the number is lower that the target we increase the lower number pointer. part_1_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) i &lt;- 1 j &lt;- length(input) input &lt;- sort(input) while (i &lt;= j) { v &lt;- input[[i]] + input[[j]] if (v == target) { return (input[[i]] * input[[j]]) } else if (v &lt; target) { i &lt;- i + 1 } else { j &lt;- j - 1 } } NULL } Again, we can test that this method works. part_1_improved(sample, 2020) == 514579 ## [1] TRUE We can now use our improved algorithm to get the result for part 1: part_1_improved(actual, 2020) ## [1] 793524 1.1.1 is the improved algorithm any better? bench::mark(part_1_naive(sample, 2020), part_1_improved(sample, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_1_naive(sample, 2020) 2.94µs 3.69µs [4m2[24m[4m5[24m[4m4[24m838. 0B 25.5 ## [90m2[39m part_1_improved(sample, 2020) 61.91µs 66.16µs [4m1[24m[4m4[24m838. 0B 17.1 For me, the improved algorithm actually takes longer on the sample data! This is because the improved algorithm has to sort the data, which is costly, and then it performs far more comparisons per iteration. However, when we have more data, these extra steps lead to big improvements, as can be seen when running with the actual data. bench::mark(part_1_naive(actual, 2020), part_1_improved(actual, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_1_naive(actual, 2020) 698.5µs 713.2µs [4m1[24m387. 0B 2.02 ## [90m2[39m part_1_improved(actual, 2020) 84.6µs 89.9µs [4m1[24m[4m0[24m835. 1.66KB 14.9 The improved algorithm was roughly 10x faster for me on the actual data. 1.2 Part 2 We can alter the naive approach from part 1 by adding in an extra for loop. part_2_naive &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) for (i in 1:(length(input) - 2)) { for (j in (i + 1):(length(input) - 1)) { for (k in (j + 1):length(input)) { if (input[[i]] + input[[j]] + input[[k]] == target) return (prod(input[c(i, j, k)])) } } } NULL } Again, we can test that this method works on the sample. part_2_naive(sample, 2020) == 241861950 ## [1] TRUE It’s much harder to adapt the improved algorithm though. My best approach involves a binary search. This function takes a sorted array, a target value, a current index into the array, and the current min/max extents to search. If the value at position i in array is less than target, we look in the left half of the array, chopping it in half by reducing max. Likewise, if the value is greater than target, we look in the right half of the array, chopping it in half by increasing min. binary_search &lt;- function(arr, target, i, min, max) { if (arr[[i]] == target) { return(i) } else if (target &lt; arr[[i]]) { max &lt;- i ni &lt;- (min + i) %/% 2 } else { min &lt;- i ni &lt;- (max + i) %/% 2 } if (ni == i) { NULL } else { binary_search(arr, target, ni, min, max) } } Our improved algorithm for part 2 involves creating two for loops to search from the end of the (sorted) input. We then remove the third loop by using a binary search to find the target value quicker. In the two for loops we first calculate the value of the adding these two items together, quickly checking to see if there is a possible solution (and exiting early if not). Then, we perform a binary search on the rest of the array for the amount required to make v equal target (2020). If we find the value, then we simply return the results. Else we continue the search by looping. part_2_improved &lt;- function(input, target) { if (length(input) == 0) stop(&quot;empty list&quot;) input &lt;- sort(input) for (j in length(input):3) { for (i in (j - 1):2) { v &lt;- sum(input[c(i, j)]) # early termination if (v &gt;= target) next() if (v + input[[i - 1]] &lt; target) next() # binary search for a suitable value k &lt;- binary_search(input, target - v, (i + 1) %/% 2, 1, (i - 1)) if (!is.null(k)) { return (prod(input[c(i, j, k)])) } } } NULL } We can once again test that our method works on the sample data: part_2_improved(sample, 2020) == 241861950 ## [1] TRUE We can now run both approaches to see what the result is: part_2_naive(actual, 2020) ## [1] 61515678 part_2_improved(actual, 2020) ## [1] 61515678 1.2.1 Is our improved algorithm better this time? Once again, we can benchmark the two approaches. bench::mark(part_2_naive(actual, 2020), part_2_improved(actual, 2020)) ## [90m# A tibble: 2 x 6[39m ## expression min median `itr/sec` mem_alloc `gc/sec` ## [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;bch:tm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m part_2_naive(actual, 2020) 111ms 111ms 8.93 0B 5.96 ## [90m2[39m part_2_improved(actual, 2020) 15ms 16ms 63.2 1.66KB 485. On my machine the improved approach is again about 10x quicker, though there are more memory allocations and GC (garbage collection’s) happening, so the total execution time is not quite 10x. "],["password-philosophy.html", "Day 2 Password Philosophy 2.1 Part 1 2.2 Part 2", " Day 2 Password Philosophy This is my attempt to solve Day 2. sample &lt;- read_lines(&quot;samples/day_02_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_02_input.txt&quot;) 2.1 Part 1 We need to convert each string into a list that contains the following: minimum number of occurrences of the character maximum number of occurrences of the character the character that must be present the password Originally, I wrote the following function to handle this step: split_input &lt;- function(input) { input %&gt;% # first, split the string into the bit before the password, and the password str_split(&quot;: &quot;) %&gt;% # now, we can iterate over the results (each line of data) map(function(.x) { # find the min/max values from the first part of the input string .x mv &lt;- .x[[1]] %&gt;% # we can remove the last 2 characters of the string (the character) str_sub(1, -3) %&gt;% # now we can split the string into the min and max values str_split(&quot;-&quot;) %&gt;% # str_split is vectorised, but we only want the first results as we are # dealing with one line at a time: # the first result will contain two values pluck(1) %&gt;% # now convert these to integers as.integer() # we can now return the results list( min = mv[[1]], max = mv[[2]], character = str_sub(.x[[1]], -1, -1), password = .x[[2]] ) }) } But, after seeing a post by @antoine_fabri on Twitter I discovered the {unglue} package which makes this much easier, and neater! split_input &lt;- function(input) { unglue::unglue(input, &quot;{min}-{max} {character}: {password}&quot;, convert = TRUE) } We can see what our split_input function does to the sample data, looking at just the first item str(split_input(sample)[[1]]) ## &#39;data.frame&#39;: 1 obs. of 4 variables: ## $ min : int 1 ## $ max : int 3 ## $ character: chr &quot;a&quot; ## $ password : chr &quot;abcde&quot; Now we can build a function to return the valid passwords. part_1_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # extract the matching values from the string, we can then count the size of # the vector to find how many times that character appeared in the string lp &lt;- length(str_extract_all(i$password, i$character)[[1]]) # check to see if the password is valid i$min &lt;= lp &amp; lp &lt;= i$max } input %&gt;% split_input() %&gt;% # run the is_valid function on each of the input values, keeping only the # valid passwords keep(is_valid) %&gt;% # pull out the password value from each of the lists map_chr(&quot;password&quot;) } part_1_valid_passwords(sample) ## 1 3 ## &quot;abcde&quot; &quot;ccccccccc&quot; This matches with the example given on the AOC website. We can now try to solve the first part: length(part_1_valid_passwords(actual)) ## [1] 493 2.2 Part 2 We can use the split_input function again, but modifiy the is_valid function slightly. part_2_valid_passwords &lt;- function(input) { is_valid &lt;- function(i) { # as per part 1, but this time extract the characters in the password at # position min and max a &lt;- str_sub(i$password, i$min, i$min) == i$character b &lt;- str_sub(i$password, i$max, i$max) == i$character # we can now xor these values: if both a and b are true xor = FASLE xor(a, b) } input %&gt;% split_input() %&gt;% keep(is_valid) %&gt;% map_chr(&quot;password&quot;) } part_2_valid_passwords(sample) ## 1 ## &quot;abcde&quot; This matches the example, so we can now solve part 2. length(part_2_valid_passwords(actual)) ## [1] 593 "],["toboggan-trajectory.html", "Day 3 Toboggan Trajectory 3.1 Part 1 3.2 Part 2", " Day 3 Toboggan Trajectory This is my attempt to solve Day 3. sample &lt;- read_lines(&quot;samples/day_03_sample.txt&quot;) actual &lt;- read_lines(&quot;inputs/day_03_input.txt&quot;) 3.1 Part 1 I think it will be easier to convert the map to a 0-1 matrix to solve today’s problem. We won’t need to infinitely replicate the pattern to the right as we can just use modular arithmetic to index into the matrix. input_to_matrix &lt;- function(input) { input %&gt;% # extract each character from the input str_extract_all(&quot;.&quot;, simplify = TRUE) %&gt;% # if a value is &quot;#&quot; then TRUE, else FALSE `==`(&quot;#&quot;) %&gt;% # convert the TRUE&#39;s to 1, FALSE&#39;s to 0 apply(c(1,2), as.integer) } sample_matrix &lt;- input_to_matrix(sample) actual_matrix &lt;- input_to_matrix(actual) sample_matrix ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] ## [1,] 0 0 1 1 0 0 0 0 0 0 0 ## [2,] 1 0 0 0 1 0 0 0 1 0 0 ## [3,] 0 1 0 0 0 0 1 0 0 1 0 ## [4,] 0 0 1 0 1 0 0 0 1 0 1 ## [5,] 0 1 0 0 0 1 1 0 0 1 0 ## [6,] 0 0 1 0 1 1 0 0 0 0 0 ## [7,] 0 1 0 1 0 1 0 0 0 0 1 ## [8,] 0 1 0 0 0 0 0 0 0 0 1 ## [9,] 1 0 1 1 0 0 0 1 0 0 0 ## [10,] 1 0 0 0 1 1 0 0 0 0 1 ## [11,] 0 1 0 0 1 0 0 0 1 0 1 Now that we have 0-1 matrices for the sample and actual data, we can consider how to solve the puzzle. For each row that we move down the matrix, we need to move 3 to the right (starting from [1,1]). Now, the pattern repeats infinitely to the right; however, we do not need to repeat the matrix at all. We can simply “wrap around” back to 1 when we reach the 12th column. In this case, we want to start from 1, then move 3 to the right to 4, then to 7 and 10. But after that we would land at 13, which is the same as being at position 2. We can achieve this using the “remainder” (%%) operator. This is 0 based however, so we need to subtract 1 from the row number and add 1 at the end: (3 * (1:11 - 1)) %% 11 + 1 ## [1] 1 4 7 10 2 5 8 11 3 6 9 We can now build a function to work out which “trees” we would land on by traversing the matrix. part_1 &lt;- function(input) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in 1:nrow(m)) m[i, (3 * (i - 1)) %% ncol(m) + 1] &lt;- 1 # just standard multiplication, not matrix multiplication sum(input * m) } We can check that this function matches the sample provided: part_1(sample_matrix) == 7 ## [1] TRUE We can now run the part 1 function on the actual data: part_1(actual_matrix) ## [1] 151 3.2 Part 2 We now need to adapt our function from part 1 to work with different step sizes. part_2 &lt;- function(input, down, right) { # create a matrix the same size as input, first filled with 0&#39;s m &lt;- input * 0 # but replace with a 1 where we would land on that row for (i in seq(1, nrow(m), down)) { # our for loop now skips certain rows, but we need to alter our index to be # based on the current step that we are on: so we divide (i - 1) by the down # step size m[i, (right * (i - 1) / down) %% ncol(m) + 1] &lt;- 1 } # just standard multiplication, not matrix multiplication. because our trees # are encoded by a 1, and the positions we land are encoded by a 1, we will # find the trees that we encounter iff both positions in input and m are 1. # The value in the resultant matrix will be a 1 in those positions, # otherwise 0. We can then simply sum the matrix. sum(input * m) } We can check that this function matches the sample provided: all( part_2(sample_matrix, 1, 1) == 2, part_2(sample_matrix, 1, 3) == 7, part_2(sample_matrix, 1, 5) == 3, part_2(sample_matrix, 1, 7) == 4, part_2(sample_matrix, 2, 1) == 2 ) ## [1] TRUE We can now run the part 1 function on the actual data: prod( part_2(actual_matrix, 1, 1), part_2(actual_matrix, 1, 3), part_2(actual_matrix, 1, 5), part_2(actual_matrix, 1, 7), part_2(actual_matrix, 2, 1) ) ## [1] 7540141059 "]]
