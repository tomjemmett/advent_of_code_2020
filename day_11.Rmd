# Seating System

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(crayon.enabled = NULL)
library(tidyverse)
```

This is my attempt to solve [Day 11](https://adventofcode.com/2020/day/11).

```{r load data}
sample <- read_lines("samples/day_11_sample.txt")
actual <- read_lines("inputs/day_11_input.txt")
```

## Part 1

We are given that in our input:

- `.` is the floor
- `L` is an empty seat
- `#` is an occupied seat

It will make our life simpler to add a border of empty seats round our inputs, and convert the input to a matrix of
individual characters

```{r part 1 process input}
process_input <- function(input) {
  dl <- paste(rep(".", str_length(input[[1]])), collapse = "")
  m <- paste0(".", c(dl, input, dl), ".") %>%
    str_extract_all(".", simplify = TRUE)
  
  # give this matrix an s3 class of "day11"
  structure(m, class = c("day11", class(m)))
}

# implement a print method for our day11 class
print.day11 <- function(x, ...) {
  cat(paste(apply(x, 1, paste, collapse = ""), collapse = "\n"), "\n")
}

psample <- process_input(sample)
pactual <- process_input(actual)
```

We can now have a quick look at our sample input:

```{r part 1 pretty print}
psample
```

Now we can build a function to run n iteration's:

```{r part 1 run iteration}
p1_run_iterations <- function(input, n = 1, count = 0) {
  # this is a recursive function, when n is less than 1 stop iterating and
  # return whatever input is given
  if (n < 1) return (list(input = input, count = count))
  
  # take a copy of the current state - we will modify this copied state and
  # return it for the next iteration
  next_state <- input
  for (r in 2:(nrow(input) - 1)) {
    for (c in 2:(ncol(input) - 1)) {
      # skip this cell if it's a .
      if (input[r, c] == ".") next()
      # get adjacent seats
      adjacent <- c(input[r - 1, c - 1],
                    input[r - 1, c    ],
                    input[r - 1, c + 1],
                    input[r    , c - 1],
                    input[r    , c + 1],
                    input[r + 1, c - 1],
                    input[r + 1, c    ],
                    input[r + 1, c + 1])
      # count how many are occupied
      occupied <- sum(ifelse(adjacent == "#", 1, 0))
      
      if (input[r, c] == "L") {
        if (occupied == 0) {
          next_state[r, c] <- "#"
        }
      } else {
        # it can only be "#" now
        if (occupied >= 4) {
          next_state[r, c] <- "L"
        }
      }
    }
  }
  
  if (all(next_state == input)) {
    return (list(input = input, count = count))
  }
  
  # run the next itertion, decreasing n by 1
  p1_run_iterations(next_state, n - 1, count + 1)
}
```

We can now test our function runs as expected on the sample.

```{r part 1 sample test 1}
p1_run_iterations(psample)
```

```{r part 1 sample test 2}
p1_run_iterations(psample, 2)
```

These match the examples, we just need to check it terminates correctly:

```{r part 1 sample test 3}
p1s <- p1_run_iterations(psample, Inf)
p1s$count == 5
```

We just need a way to count the seats occupied now:

```{r part 1 function}
count_seats <- function(x) {
  sum(x$input == "#")
}
```

Which we can run on the variable `p1s` from above:

```{r part 1 sample test 4}
part_1(p1s) == 37
```

We can now run our functions on the actual data:

```{r part 1 actual}
actual %>%
  process_input() %>%
  p1_run_iterations(Inf) %>%
  count_seats()
```

## Part 2

We now need to modify our run iterations function. I am going to embed a function that will search for the first seat,
and update the tolerance from 4 to 5. The rest of the function remains as per part 1.

```{r part 1 run iteration}
p2_run_iterations <- function(input, n = 1, count = 0) {
  # this is a recursive function, when n is less than 1 stop iterating and
  # return whatever input is given
  if (n < 1) return (list(input = input, count = count))
  
  # take a copy of the current state - we will modify this copied state and
  # return it for the next iteration
  next_state <- input
  for (r in 2:(nrow(input) - 1)) {
    for (c in 2:(ncol(input) - 1)) {
      # skip this cell if it's a .
      if (input[r, c] == ".") next()
      
      # get first seat
      find_first_seat <- function(rd, cd) {
        rr <- r
        cc <- c
        repeat {
          rr <- rr + rd
          cc <- cc + cd
          if (rr < 1 | rr > nrow(input) |
              cc < 1 | cc > ncol(input) ) {
            return (".")
          } else if (input[rr, cc] != ".") {
            return (input[rr, cc])
          }
        }
      }
      adjacent <- list(
        rd = c(-1, -1, -1,  0,  0,  1,  1,  1),
        cd = c(-1,  0,  1, -1,  1, -1,  0,  1)
      ) %>%
        pmap(find_first_seat)
      
      # count how many are occupied
      occupied <- sum(ifelse(adjacent == "#", 1, 0))
      
      if (input[r, c] == "L") {
        if (occupied == 0) {
          next_state[r, c] <- "#"
        }
      } else {
        # it can only be "#" now
        if (occupied >= 5) {
          next_state[r, c] <- "L"
        }
      }
    }
  }
  
  if (all(next_state == input)) {
    return (list(input = input, count = count))
  }
  
  # run the next itertion, decreasing n by 1
  p2_run_iterations(next_state, n - 1, count + 1)
}
```

We can test our function works as expected after 1 iteration:

```{r part 2 sample test 1}
psample %>%
  p2_run_iterations(1) 
```

And after 2 iterations:

```{r part 2 sample test 2}
psample %>%
  p2_run_iterations(2) 
```

We can use the `count_seats()` function again to test our new function works:

```{r part 2 sample test 3}
psample %>%
  p2_run_iterations(Inf) %>%
  count_seats() == 26
```

Now we can run the function on our actual data:

```{r part 2 actual}
pactual %>%
  p2_run_iterations(Inf) %>%
  count_seats()
```

(This takes some time to run... there is likely to be a more optimal solution!)
